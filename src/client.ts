import bitwise from 'bitwise';
import { Byte, UInt4 } from 'bitwise/types';
import { KeyPair } from 'elliptic';
import superagent from 'superagent';
import bitcoin from './bitcoin';
import { sha256 } from 'hash.js/lib/hash/sha';
import { KVRecord, SignData, GetKvRecordsData } from './types/client';
import { Constants } from './index';
import {
  EXTERNAL,
  ADDR_STR_LEN,
  ASCII_REGEX,
  BASE_URL,
  decResLengths,
  deviceCodes,
  encReqCodes,
  ENC_MSG_LEN,
  getFwVersionConst,
  messageConstants,
  REQUEST_TYPE_BYTE,
  responseCodes,
  responseMsgs,
  signingSchema,
  VERSION_BYTE,
} from './constants';
import ethereum from './ethereum';
import {
  buildGenericSigningMsgRequest,
  parseGenericSigningResponse,
} from './genericSigning';
import {
  aes256_decrypt,
  aes256_encrypt,
  checksum,
  getP256KeyPair,
  getP256KeyPairFromPub,
  isValidAssetPath,
  parseDER,
  parseLattice1Response,
  promisifyCb,
  toPaddedDER,
  randomBytes,
} from './util';
const EMPTY_WALLET_UID = Buffer.alloc(32);

/**
 * `Client` is a class-based interface for managing a Lattice device.
 */
export class Client {
  /** Is the Lattice paired with this Client. */
  public isPaired: boolean;
  /** The time to wait for a response before cancelling. */
  public timeout: number;

  private baseUrl: string;
  private name: string;
  private key: KeyPair;
  private privKey: Buffer;
  private retryCount: number;
  private fwVersion: Buffer;
  private skipRetryOnWrongWallet: boolean;

  /** Temporary secret that is generated by the Lattice device */
  private ephemeralPub: KeyPair;
  /** The ID of the connected Lattice */
  private deviceId: string;
  /** Information about the current wallet. Should be null unless we know a wallet is present */
  private activeWallets: {
    internal: {
      /** 32 byte id */
      uid: Buffer;
      /** 20 char (max) string */
      name: Buffer;
      /** 4 byte flag */
      capabilities: number;
      /** External or internal wallet */
      external: boolean;
    };
    external: {
      /** 32 byte id */
      uid: Buffer;
      /** 20 char (max) string */
      name: Buffer;
      /** 4 byte flag */
      capabilities: number;
      /** External or internal wallet */
      external: boolean;
    };
  };

  /**
   * @param params - Parameters are passed as an object.
   */
  constructor({
    baseUrl,
    name,
    privKey,
    stateData,
    timeout,
    retryCount,
    skipRetryOnWrongWallet,
  }: {
    /** The base URL of the signing server. */
    baseUrl?: string;
    /** The name of the client. */
    name?: string;
    /** The private key of the client.*/
    privKey?: Buffer;
    /** Number of times to retry a request if it fails. */
    retryCount?: number;
    /** The time to wait for a response before cancelling. */
    timeout?: number;
    /** User can pass in previous state data to rehydrate connected session */
    stateData?: string;
    /** If true we will not retry if we get a wrong wallet error code */
    skipRetryOnWrongWallet: boolean;
    }) {
    // Default state params
    // -----
    this.ephemeralPub = null;
    this.deviceId = null;
    this.isPaired = false;
    this.activeWallets = {
      internal: {
        uid: EMPTY_WALLET_UID, // 32 byte id
        name: null, // 20 char (max) string
        capabilities: null, // 4 byte flag
        external: false,
      },
      external: {
        uid: EMPTY_WALLET_UID, // 32 byte id
        name: null, // 20 char (max) string
        capabilities: null, // 4 byte flag
        external: true,
      },
    };
    this.skipRetryOnWrongWallet = skipRetryOnWrongWallet || false;

    // The user may pass in state data to rehydrate a session that was previously cached
    // -----
    if (stateData) {
      this._unpackAndApplyStateData(stateData);
      return;
    }

    // Other params to check if `stateData` is not included
    // -----
    // `baseUrl` describes where to send HTTP requests
    this.baseUrl = baseUrl || BASE_URL;
    // `name` is a human readable string associated with this app on the Lattice
    if (name && (name.length < 5 || name.length > 24)) {
      throw new Error('`name` must be 5-24 characters');
    }
    this.name = name || 'Unknown';
    // `privKey` is used to generate a keypair, which is used for maintaining an encrypted messaging
    // channel with the target Lattice
    this.privKey = privKey || randomBytes(32);
    this.key = getP256KeyPair(this.privKey);
    // `retryCount` defines the number of automatic retries for asynchronous requests. Retries only
    // happen for certain device errors which indicate retrying is allowed.
    this.retryCount = retryCount || 3;
    // `timeout` is the number of milliseconds allowed before terminating asynchronous requests if
    // no response is returned in time
    this.timeout = timeout || 60000;
  }

  /**
   * Get a JSON string containing state data that can be used to rehydrate a session. Pass the
   * contents of this to the constructor as `stateData` to rehydrate.
   */
  public getStateData () {
    return this._packStateData();
  }

  /**
   * `getFwVersion` gets the firmware version of the paired device.
   * @returns Either an object with semver properties (fix, minor, and major) or `null`.
   */
  public getFwVersion (): {
    fix: number;
    minor: number;
    major: number;
  } | null {
    if (this.fwVersion && this.fwVersion.length >= 3) {
      return {
        fix: this.fwVersion[0],
        minor: this.fwVersion[1],
        major: this.fwVersion[2],
      };
    }
    return null;
  }

  //=======================================================================
  // LATTICE FUNCTIONS
  //=======================================================================

  /**
   * `connect` will attempt to contact a device based on its deviceId. The response should include
   * an ephemeral public key, which is used to pair with the device in a later request.
   * @category Lattice
   */
  public connect (
    deviceId: string,
    _cb?: (err?: string, isPaired?: boolean) => void,
  ): Promise<boolean> {
    return new Promise((resolve, reject) => {
      let cb = promisifyCb(resolve, reject, _cb);
      // User may "re-connect" if a device ID has previously been stored
      if (typeof deviceId === 'function') {
        if (!this.deviceId)
          return cb(
            'No device ID has been stored. Please connect with your device ID first.',
          );
        cb = deviceId;
      } else {
        // If the user passes in a device ID, connect to that device and save the new ID for future
        // use.
        this.deviceId = deviceId;
      }
      const param = this._buildRequest(deviceCodes.CONNECT, this.pubKeyBytes());
      this._request(param, null, (err, res) => {
        if (err) return cb(err);
        this.isPaired = this._handleConnect(res) || false;
        // If we are paired and are on older firmware (<0.14.1), we need a follow up request to sync
        // wallet state.
        if (this.isPaired && !this._fwVersionGTE(0, 14, 1)) {
          this.fetchActiveWallet((err) => {
            return cb(err, this.isPaired);
          });
        } else {
          return cb(err, this.isPaired);
        }
      });
    });
  }

  /**
   * If a pairing secret is provided, `pair` uses it to sign a hash of the public key, name, and
   * pairing secret. It then sends the name and signature to the device. If no pairing secret is
   * provided, `pair` sends a zero-length name buffer to the device.
   * @category Lattice
   * @returns The active wallet object.
   */
  public pair (
    pairingSecret: string,
    _cb?: (err?: string, hasActiveWallet?: boolean) => void,
  ): Promise<boolean> {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      // Build the secret hash from the salt
      const pubKey = this.pubKeyBytes();
      const nameBuf = Buffer.alloc(25);
      if (this.name.length < 5 || this.name.length > 24) {
        return cb('Invalid length for name provided. Must be 5-24 characters.');
      }
      if (pairingSecret.length > 0) {
        // If a pairing secret of zero length is passed in, it usually indicates we want to cancel
        // the pairing attempt. In this case we pass a zero-length name buffer so the firmware can
        // know not to draw the error screen. Note that we still expect an error to come back
        // (RESP_ERR_PAIR_FAIL)
        nameBuf.write(this.name);
      }
      // Make sure we add a null termination byte to the pairing secret
      const preImage = Buffer.concat([
        pubKey,
        nameBuf,
        Buffer.from(pairingSecret),
      ]);
      const hash = Buffer.from(sha256().update(preImage).digest('hex'), 'hex');
      const sig = this.key.sign(hash); // returns an array, not a buffer
      const derSig = toPaddedDER(sig);
      const payload = Buffer.concat([nameBuf, derSig]);

      // Build the request
      this._request(payload, 'FINALIZE_PAIRING', (err, res) => {
        if (err) return cb(err);
        // Recover the ephemeral key
        const errStr = this._handlePair(res);
        if (errStr) return cb(errStr);
        // Try to get the active wallet once pairing is successful
        this.fetchActiveWallet((err) => {
          if (err) return cb(err);
          return cb(null, this.hasActiveWallet());
        });
      });
    });
  }

  /**
   * `test` takes a data object with a testID and a payload, and sends them to the device.
   * @category Lattice
   */
  private test (
    data: { payload: Buffer, testID: number },
    _cb?: (err?: string, data?: Buffer) => void,
  ) {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      if (!data.payload)
        return cb('First argument must contain `testID` and `payload` fields.');
      const TEST_DATA_SZ = 500;
      const payload = Buffer.alloc(TEST_DATA_SZ + 6);
      payload.writeUInt32BE(data.testID, 0);
      payload.writeUInt16BE(data.payload.length, 4);
      data.payload.copy(payload, 6);
      this._request(payload, 'TEST', (err, res) => {
        if (err) return cb(err);
        const decrypted = this._handleEncResponse(res, decResLengths.test);
        if (decrypted.err !== null) return cb(decrypted.err);
        return cb(null, decrypted.data.slice(65)); // remove ephem pub
      });
    });
  }

  /**
   * `getAddresses` takes a starting path and a number to get the addresses associated with the
   * active wallet.
   * @category Lattice
   * @returns An array of addresses.
   */
  public getAddresses (
    opts: { startPath: number[], n: UInt4, flag: UInt4 },
    _cb?: (err?: string, data?: Buffer | string[]) => void,
  ): Promise<Buffer | string[]> {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      const MAX_ADDR = 10;
      const { startPath, n, flag = 0 } = opts;
      if (startPath === undefined || n === undefined)
        return cb('Please provide `startPath` and `n` options');
      if (startPath.length < 2 || startPath.length > 5)
        return cb('Path must include between 2 and 5 indices');
      if (n > MAX_ADDR)
        return cb(`You may only request ${MAX_ADDR} addresses at once.`);

      const fwConstants = getFwVersionConst(this.fwVersion);
      const flags = fwConstants.getAddressFlags || [];
      const isPubkeyOnly =
        flags.indexOf(flag) > -1 &&
        (flag === EXTERNAL.GET_ADDR_FLAGS.ED25519_PUB ||
          flag === EXTERNAL.GET_ADDR_FLAGS.SECP256K1_PUB);
      if (!isPubkeyOnly && !isValidAssetPath(startPath, fwConstants)) {
        return cb('Parent derivation path is not supported');
      }

      let sz = 32 + 20 + 1; // walletUID + 5 u32 indices + count/flag
      if (fwConstants.varAddrPathSzAllowed) {
        sz += 1; // pathDepth
      } else if (startPath.length !== 5) {
        return cb(
          'Your Lattice firmware only supports derivation paths with 5 indices. Please upgrade.',
        );
      }
      const payload = Buffer.alloc(sz);
      let off = 0;

      // WalletUID
      const wallet = this.getActiveWallet();
      if (wallet === null) return cb('No active wallet.');
      wallet.uid.copy(payload, off);
      off += 32;
      // Build the start path (5x u32 indices)
      if (fwConstants.varAddrPathSzAllowed) {
        payload.writeUInt8(startPath.length, off);
        off += 1;
      }
      for (let i = 0; i < 5; i++) {
        if (i <= startPath.length) payload.writeUInt32BE(startPath[i], off);
        off += 4;
      }
      // Specify the number of subsequent addresses to request. We also allow the user to skip the
      // cache and request any address related to the asset in the wallet.
      let val,
        flagVal: UInt4 = 0;
      if (fwConstants.addrFlagsAllowed) {
        // A 4-bit flag can be used for non-standard address requests This needs to be combined with
        // `n` as a 4 bit value
        flagVal =
          fwConstants.getAddressFlags &&
            fwConstants.getAddressFlags.indexOf(flag) > -1
            ? flag
            : 0;
        const flagBits = bitwise.nibble.read(flagVal);
        const countBits = bitwise.nibble.read(n);
        val = bitwise.byte.write(flagBits.concat(countBits) as Byte);
      } else {
        // Very old firmware does not support this flag. We can deprecate this soon.
        val = n;
      }
      payload.writeUInt8(val, off);
      off++;
      return this._request(payload, 'GET_ADDRESSES', (err, res) => {
        if (err) return cb(err);
        const parsedRes = this._handleGetAddresses(res, flagVal);
        if (parsedRes.err) return cb(parsedRes.err);
        return cb(null, parsedRes.data);
      });
    });
  }

  /**
   * `sign` builds and sends a request for signing to the device.
   * @category Lattice
   * @returns The response from the device.
   */
  public sign (
    opts: { data, currency: string },
    _cb?: (err?: string, data?: SignData) => void,
    cachedData = null,
    nextCode = null,
  ): Promise<SignData> {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      let { data } = opts;
      if (!data) {
        return cb('You must provide `data`');
      }
      // All transaction requests must be put into the same sized buffer. This comes from
      // sizeof(GpTransactionRequest_t), but note we remove the 2-byte schemaId since it is not
      // returned from our resolver. Note that different firmware versions may have different data
      // sizes.
      const fwConstants = getFwVersionConst(this.fwVersion);
      // Build the signing request payload to send to the device. If we catch bad params, return an
      // error instead
      data = { fwConstants, ...data };
      let req, reqPayload, schema;
      let currency = null;
      if (cachedData !== null && nextCode !== null) {
        currency = cachedData.currency;
        req = cachedData;
        reqPayload = Buffer.concat([nextCode, req.extraDataPayloads.shift()]);
        schema = signingSchema.EXTRA_DATA;
      } else {
        currency = opts.currency;
        try {
          // TEMPORARY BRIDGE -- DEPRECATE ME In v0.15.0 Lattice firmware removed the legacy ETH
          // signing path, so we need to convert such requests to general signing requests using the
          // EVM decoder. NOTE: Not every request can be converted, so users should switch to using
          // general signing requests for newer firmware versions. EIP1559 and EIP155 legacy
          // requests will convert, but others may not.
          const useEVMLegacyConverter =
            fwConstants.genericSigning &&
            fwConstants.genericSigning.encodingTypes &&
            fwConstants.genericSigning.encodingTypes.EVM;
          if (currency === 'ETH' && useEVMLegacyConverter) {
            console.warn(
              'Using the legacy ETH signing path. This will soon be deprecated. ' +
              'Please switch to general signing request.',
            );
            let payload;
            try {
              payload = ethereum.ethConvertLegacyToGenericReq(data);
            } catch (err) {
              return cb(
                'Could not convert legacy request. Please switch to a general signing ' +
                'request. See gridplus-sdk docs for more information.',
              );
            }
            data = {
              fwConstants,
              encodingType: EXTERNAL.SIGNING.ENCODINGS.EVM,
              curveType: EXTERNAL.SIGNING.CURVES.SECP256K1,
              hashType: EXTERNAL.SIGNING.HASHES.KECCAK256,
              signerPath: data.signerPath,
              payload,
            };
            currency = null;
          }

          if (currency === 'ETH') {
            // Legacy signing pathway -- should deprecate in the future
            req = ethereum.buildEthereumTxRequest(data);
          } else if (currency === 'ETH_MSG') {
            req = ethereum.buildEthereumMsgRequest(data);
          } else if (currency === 'BTC') {
            req = bitcoin.buildBitcoinTxRequest(data);
          } else {
            req = buildGenericSigningMsgRequest(data);
          }
        } catch (err) {
          return cb(`Error building signing request: ${err.message}`);
        }
        if (req.err !== undefined) return cb(req.err);
        if (req.payload.length > fwConstants.reqMaxDataSz)
          return cb('Transaction is too large');
        reqPayload = req.payload;
        schema = req.schema;
      }
      // Build the payload
      const payload = Buffer.alloc(2 + fwConstants.reqMaxDataSz);
      let off = 0;
      // Whether there will be follow up requests
      const hasExtraPayloads =
        req.extraDataPayloads && Number(req.extraDataPayloads.length > 0);
      payload.writeUInt8(hasExtraPayloads, off);
      off += 1;
      // Copy request schema (e.g. ETH or BTC transfer)
      payload.writeUInt8(schema, off);
      off += 1;
      // Copy the wallet UID
      const wallet = this.getActiveWallet();
      if (wallet === null) return cb('No active wallet.');
      wallet.uid.copy(payload, off);
      off += wallet.uid.length;
      // Build data based on the type of request Copy the payload of the request
      reqPayload.copy(payload, off);
      // Construct the encrypted request and send it
      return this._request(payload, 'SIGN_TRANSACTION', (err, res) => {
        if (err) {
          // If there was another error caught, return it
          if (err) return cb(err);
        } else if (hasExtraPayloads) {
          const decrypted = this._handleEncResponse(res, decResLengths.sign);
          nextCode = decrypted.data.slice(65, 73);
          if (!cachedData) {
            cachedData = req;
            // We need to keep track of the currency to handler the decoding
            cachedData.currency = currency;
          }
          return this.sign(opts, cb, cachedData, nextCode);
        } else {
          // Correct wallet and no errors -- handle the response
          try {
            const parsedRes = this._handleSign(res, currency, req);
            return cb(null, parsedRes);
          } catch (err) {
            return cb(err.message);
          }
        }
      });
    });
  }

  /**
   * `addDecoders` sends an RLP-encoded list of decoders to the Lattice. A "decoder" is a piece of
   * data that can be used to decode some data in the future. The best example of this is the ABI
   * defintion of a contract function. This definition is used to deserialize EVM calldata for
   * future requests that call the specified function (as determined by the function selector).
   * 
   * NOTE: The CRUD API to manage calldata decoders is written, but is currently
   * compiled out of firmware to free up code space. For now we will leave
   * these functions commented out.
   * NOTE: You will need to re-enable `import { encode as rlpEncode } from 'rlp';`
   * 
   * @deprecated
   * @category Lattice
   * @returns The decrypted response.
   */
  public addDecoders (
    opts: { decoderType: number, decoders: Buffer[] },
    _cb?: (err?: string) => void,
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      // TODO: Update function comment if/when this is re-enabled.
      return cb(
        'Feature currently disabled in Lattice firmware. Please include ' +
        'calldata decoder data in the signing request itself.'
      );
      /*
      const { decoders, decoderType } = opts;
      const fwConstants = getFwVersionConst(this.fwVersion);
      if (!fwConstants.maxDecoderBufSz) {
        return cb('Please update Lattice firmware.');
      }
      const payload = Buffer.alloc(3 + fwConstants.maxDecoderBufSz);
      const encDecoders = Buffer.from(rlpEncode(decoders));
      if (encDecoders.length > fwConstants.maxDecoderBufSz) {
        return cb(
          'Too much data to make request. Please remove some decoders.',
        );
      }
      payload.writeUInt8(decoderType, 0);
      payload.writeUInt16LE(encDecoders.length, 1);
      encDecoders.copy(payload, 3);
      return this._request(
        payload,
        'ADD_DECODERS',
        (err, res, responseCode) => {
          if (responseCode && responseCode !== responseCodes.RESP_SUCCESS) {
            return cb('Error making request.');
          } else if (err) {
            return cb(err);
          }
          this._handleEncResponse(res, decResLengths.empty);
          return cb(null);
        },
      );
      */
    });
  }

  /**
   * `getDecoders` fetches a set of decoders saved on the target Lattice.
   *  
   * NOTE: The CRUD API to manage calldata decoders is written, but is currently
   * compiled out of firmware to free up code space. For now we will leave
   * these functions commented out.
   * 
   * @deprecated
   * @category Lattice
   * @returns The decrypted response.
   */
  public getDecoders (
    opts: {
      decoderType: number;
      n?: number;
      startIdx?: number;
      skipTotal?: boolean;
    },
    _cb?: (err?: string, data?: { decoders: Buffer[], total: number }) => void,
  ): Promise<{ decoders: Buffer[], total: number }> {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      // TODO: Update function comment if/when this is re-enabled.
      return cb(
        'Feature currently disabled in Lattice firmware. Please include ' +
        'calldata decoder data in the signing request itself.'
      );
      /*
      const { n = 1, startIdx = 0, skipTotal = false, decoderType } = opts;
      const fwConstants = getFwVersionConst(this.fwVersion);
      if (!fwConstants.maxDecoderBufSz) {
        return cb('Please update Lattice firmware.');
      }
      if (n < 1) {
        return cb('Must request at least one record (n=0)');
      } else if (n < 0 || startIdx < 0) {
        return cb('Both `n` and `startIdx` must be >=0');
      }
      const payload = Buffer.alloc(10);
      payload.writeUInt8(decoderType, 0);
      payload.writeUInt8(skipTotal ? 1 : 0, 1);
      payload.writeUInt32LE(startIdx, 2);
      payload.writeUInt32LE(n, 6);
      return this._request(payload, 'GET_DECODERS', (err, res) => {
        if (err) {
          return cb(err);
        }
        // Correct wallet and no errors -- handle the response
        const d = this._handleEncResponse(res, decResLengths.getDecoders);
        if (d.err) {
          return cb(d.err);
        }
        // Decode the response
        const decoders = [];
        let off = 65; // Skip 65 byte pubkey prefix
        const numFetched = d.data.readUInt32LE(off);
        off += 4;
        const total = d.data.readUInt32LE(off);
        off += 4;
        for (let i = 0; i < numFetched; i++) {
          const sz = d.data.readUInt32LE(off);
          off += 4;
          decoders.push(d.data.slice(off, off + sz));
          off += sz;
        }
        return cb(null, { decoders, total });
      });
      */
    });
  }

  /**
   * `removeDecoders` requests removal of a set of decoders on the target Lattice.
   * 
   * NOTE: The CRUD API to manage calldata decoders is written, but is currently
   * compiled out of firmware to free up code space. For now we will leave
   * these functions commented out.
   * NOTE: You will need to re-enable `import { encode as rlpEncode } from 'rlp';`
   * 
   * @deprecated
   * @category Lattice
   * @returns The decrypted response.
   */
  public removeDecoders (
    opts: { decoderType: number, decoders?: Buffer[], rmAll?: boolean },
    _cb?: (err?: string, data?: number) => void,
  ): Promise<number> {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      // TODO: Update function comment if/when this is re-enabled.
      return cb(
        'Feature currently disabled in Lattice firmware. Please include ' +
        'calldata decoder data in the signing request itself.'
      );
      /*
      const { decoders, decoderType, rmAll = false } = opts;
      const fwConstants = getFwVersionConst(this.fwVersion);
      if (!fwConstants.maxDecoderBufSz) {
        return cb('Please update Lattice firmware.');
      } else if ((!decoders || !decoders.length) && !rmAll) {
        return cb(
          'At least one decoder must be provided unless using `rmAll`.',
        );
      }
      const payload = Buffer.alloc(3 + fwConstants.maxDecoderBufSz);
      let encDecoders = Buffer.alloc(0);
      if (decoders) {
        encDecoders = Buffer.from(rlpEncode(decoders));
        if (encDecoders.length > fwConstants.maxDecoderBufSz) {
          return cb(
            'Too much data to make request. Please remove some decoders.',
          );
        }
      }
      const sz = rmAll ? 0 : encDecoders.length;
      payload.writeUInt8(decoderType, 0);
      payload.writeUInt16LE(sz, 1);
      encDecoders.copy(payload, 3);
      return this._request(
        payload,
        'REMOVE_DECODERS',
        (err, res, responseCode) => {
          if (responseCode && responseCode !== responseCodes.RESP_SUCCESS) {
            return cb('Error making request.');
          } else if (err) {
            return cb(err);
          }
          const d = this._handleEncResponse(res, decResLengths.removeDecoders);
          if (d.err) {
            return cb(d.err);
          }
          // Decode the response
          let off = 65; // Skip 65 byte pubkey prefix
          const numRemoved = d.data.readUInt32LE(off);
          off += 4;
          return cb(null, numRemoved);
        },
      );
      */
    });
  }

  /**
   * `addPermissionV0` takes in a currency, time window, spending limit, and decimals, and builds a
   * payload to send to the Lattice.
   * 
   * NOTE: This feature has been deprecated, but may be replaced in the future.
   * 
   * @deprecated
   * @category Lattice
   */
  public addPermissionV0 (
    opts: {
      currency: string;
      timeWindow: number;
      limit: number;
      decimals: number;
      asset: string;
    },
    _cb?: (err?: string) => void,
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      return cb(
        'This feature has been deprecated and may be replaced at a later time.'
      );
      /*
      const { currency, timeWindow, limit, decimals, asset } = opts;
      if (
        !currency ||
        timeWindow === undefined ||
        limit === undefined ||
        decimals === undefined ||
        timeWindow === null ||
        limit === null ||
        decimals === null
      )
        return cb(
          'currency, timeWindow, decimals, and limit are all required options.',
        );
      else if (timeWindow === 0 || limit === 0)
        return cb('Time window and spending limit must be positive.');
      // Build the name of the permission
      let name = currency;
      if (asset) name += `_${asset}`;
      // Start building the payload
      const payload = Buffer.alloc(293);
      // Copy the name
      if (Buffer.from(name).length > 255) return cb('Asset name too long.');
      Buffer.from(name).copy(payload, 0);
      // Convert the limit to a 32 byte hex buffer and copy it in
      const limitBuf = ethereum.ensureHexBuffer(limit);
      if (limitBuf.length > 32) return cb('Limit too large.');
      limitBuf.copy(payload, 256 + (32 - limitBuf.length));
      // Copy the time window (seconds)
      payload.writeUInt32BE(timeWindow, 288);
      payload.writeUInt8(decimals, 292);
      // Encrypt the request and send it to the Lattice.
      return this._request(payload, 'ADD_PERMISSION_V0', (err, res) => {
        if (err) {
          // If there was another error caught, return it
          if (err) return cb(err);
        } else {
          // Correct wallet and no errors -- handle the response
          const d = this._handleEncResponse(res, decResLengths.empty);
          if (d.err) return cb(d.err);
          return cb(null);
        }
      });
      */
    });
  }

  /**
   * `getKvRecords` fetches a list of key-value records from the Lattice.
   * @category Lattice
   */
  public getKvRecords (
    opts: { type?: number, n?: number, start?: number },
    _cb?: (err?: string, data?: GetKvRecordsData) => void,
  ): Promise<GetKvRecordsData> {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      const { type = 0, n = 1, start = 0 } = opts;
      const fwConstants = getFwVersionConst(this.fwVersion);
      if (!fwConstants.kvActionsAllowed) {
        return cb('Unsupported. Please update firmware.');
      } else if (n < 1) {
        return cb('You must request at least one record.');
      } else if (n > fwConstants.kvActionMaxNum) {
        return cb(
          `You may only request up to ${fwConstants.kvActionMaxNum} records at once.`,
        );
      }
      const payload = Buffer.alloc(9);
      payload.writeUInt32LE(type, 0);
      payload.writeUInt8(n, 4);
      payload.writeUInt32LE(start, 5);
      // Encrypt the request and send it to the Lattice.
      return this._request(payload, 'GET_KV_RECORDS', (err, res) => {
        if (err) {
          // If there was another error caught, return it
          if (err) return cb(err);
        } else {
          // Correct wallet and no errors -- handle the response
          const d = this._handleEncResponse(res, decResLengths.getKvRecords);
          if (d.err) return cb(d.err);
          // Decode the response
          let off = 65; // Skip 65 byte pubkey prefix
          const nTotal = parseInt(
            d.data.slice(off, off + 4).toString('hex'),
            16,
          );
          off += 4;
          const nFetched = parseInt(
            d.data.slice(off, off + 1).toString('hex'),
            16,
          );
          off += 1;
          if (nFetched > fwConstants.kvActionMaxNum)
            return cb('Too many records fetched. Firmware error.');
          const records = [];
          for (let i = 0; i < nFetched; i++) {
            const r: KVRecord = {};
            r.id = parseInt(d.data.slice(off, off + 4).toString('hex'), 16);
            off += 4;
            r.type = parseInt(d.data.slice(off, off + 4).toString('hex'), 16);
            off += 4;
            r.caseSensitive =
              parseInt(d.data.slice(off, off + 1).toString('hex'), 16) === 1
                ? true
                : false;
            off += 1;
            const keySz = parseInt(
              d.data.slice(off, off + 1).toString('hex'),
              16,
            );
            off += 1;
            r.key = d.data.slice(off, off + keySz - 1).toString();
            off += fwConstants.kvKeyMaxStrSz + 1;
            const valSz = parseInt(
              d.data.slice(off, off + 1).toString('hex'),
              16,
            );
            off += 1;
            r.val = d.data.slice(off, off + valSz - 1).toString();
            off += fwConstants.kvValMaxStrSz + 1;
            records.push(r);
          }
          return cb(null, {
            records,
            total: nTotal,
            fetched: nFetched,
          });
        }
      });
    });
  }

  /**
   * `addKvRecords` takes in a set of key-value records and sends a request to add them to the
   * Lattice.
   * @category Lattice
   * @returns A callback with an error or null.
   */
  public addKvRecords (
    opts: { type?: number, records: KVRecord[], caseSensitive: boolean },
    _cb?: (err?: string) => void,
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      const { type = 0, records = {}, caseSensitive = false } = opts;
      const fwConstants = getFwVersionConst(this.fwVersion);
      if (!fwConstants.kvActionsAllowed) {
        return cb('Unsupported. Please update firmware.');
      } else if (
        typeof records !== 'object' ||
        Object.keys(records).length === 0
      ) {
        return cb(
          'One or more key-value mapping must be provided in `records` param.',
        );
      } else if (Object.keys(records).length > fwConstants.kvActionMaxNum) {
        return cb(
          `Too many keys provided. Please only provide up to ${fwConstants.kvActionMaxNum}.`,
        );
      } else if (Object.keys(records).length < 1) {
        return cb('You must provide at least one key to add.');
      }
      const payload = Buffer.alloc(1 + 139 * fwConstants.kvActionMaxNum);
      payload.writeUInt8(Object.keys(records).length, 0);
      let off = 1;
      try {
        Object.keys(records).forEach((key) => {
          if (
            typeof key !== 'string' ||
            String(key).length > fwConstants.kvKeyMaxStrSz
          ) {
            throw new Error(
              `Key ${key} too large. Must be <=${fwConstants.kvKeyMaxStrSz} characters.`,
            );
          } else if (
            typeof records[key] !== 'string' ||
            String(records[key]).length > fwConstants.kvValMaxStrSz
          ) {
            throw new Error(
              `Value ${records[key]} too large. Must be <=${fwConstants.kvValMaxStrSz} characters.`,
            );
          } else if (
            String(key).length === 0 ||
            String(records[key]).length === 0
          ) {
            throw new Error('Keys and values must be >0 characters.');
          } else if (
            !ASCII_REGEX.test(key) ||
            !ASCII_REGEX.test(records[key])
          ) {
            throw new Error('Unicode characters are not supported.');
          }
          // Skip the ID portion. This will get added by firmware.
          payload.writeUInt32LE(0, off);
          off += 4;
          payload.writeUInt32LE(type, off);
          off += 4;
          payload.writeUInt8(caseSensitive ? 1 : 0, off);
          off += 1;
          payload.writeUInt8(String(key).length + 1, off);
          off += 1;
          Buffer.from(String(key)).copy(payload, off);
          off += fwConstants.kvKeyMaxStrSz + 1;
          payload.writeUInt8(String(records[key]).length + 1, off);
          off += 1;
          Buffer.from(String(records[key])).copy(payload, off);
          off += fwConstants.kvValMaxStrSz + 1;
        });
      } catch (err) {
        return cb(`Error building request: ${err.message}`);
      }
      // Encrypt the request and send it to the Lattice.
      return this._request(payload, 'ADD_KV_RECORDS', (err, res) => {
        if (err) {
          // If there was another error caught, return it
          if (err) return cb(err);
        } else {
          // Correct wallet and no errors -- handle the response
          const d = this._handleEncResponse(res, decResLengths.empty);
          if (d.err) return cb(d.err);
          return cb(null);
        }
      });
    });
  }

  /**
   * `removeKvRecords` takes in an array of ids and sends a request to remove them from the Lattice.
   * @category Lattice
   * @returns A callback with an error or null.
   */
  public removeKvRecords (
    opts: { type: number, ids: number[] },
    _cb?: (err?: string) => void,
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      const { type = 0, ids = [] } = opts;
      const fwConstants = getFwVersionConst(this.fwVersion);
      if (!fwConstants.kvActionsAllowed) {
        return cb('Unsupported. Please update firmware.');
      } else if (!Array.isArray(ids) || ids.length < 1) {
        return cb('You must include one or more `ids` to removed.');
      } else if (ids.length > fwConstants.kvRemoveMaxNum) {
        return cb(
          `Only up to ${fwConstants.kvRemoveMaxNum} records may be removed at once.`,
        );
      }
      const payload = Buffer.alloc(5 + 4 * fwConstants.kvRemoveMaxNum);
      payload.writeUInt32LE(type, 0);
      payload.writeUInt8(ids.length, 4);
      for (let i = 0; i < ids.length; i++) {
        payload.writeUInt32LE(ids[i], 5 + 4 * i);
      }
      // Encrypt the request and send it to the Lattice.
      return this._request(payload, 'REMOVE_KV_RECORDS', (err, res) => {
        if (err) {
          // If there was another error caught, return it
          if (err) return cb(err);
        } else {
          // Correct wallet and no errors -- handle the response
          const d = this._handleEncResponse(res, decResLengths.empty);
          if (d.err) return cb(d.err);
          return cb(null);
        }
      });
    });
  }

  /**
   * Fetch the active wallet in the device.
   * @returns callback with an error or null
   */
  public fetchActiveWallet (_cb?: (err?: string, wallet?: Buffer) => void) {
    return new Promise((resolve, reject) => {
      const cb = promisifyCb(resolve, reject, _cb);
      const payload = Buffer.alloc(0);
      return this._request(payload, 'GET_WALLETS', (err, res) => {
        if (err) {
          this._resetActiveWallets();
          return cb(err);
        }
        return cb(this._handleGetWallets(res));
      });
    });
  }

  //=======================================================================
  // INTERNAL FUNCTIONS These handle the logic around building requests and consuming responses.
  // They take into account the Lattice's serialization scheme among other protocols.
  //=======================================================================

  /**
   * Get the shared secret, derived via ECDH from the local private key and the ephemeral public key
   * @internal
   * @returns Buffer
   */
  private _getSharedSecret () {
    // Once every ~256 attempts, we will get a key that starts with a `00` byte, which can lead to
    // problems initializing AES if we don't force a 32 byte BE buffer.
    return Buffer.from(
      this.key.derive(this.ephemeralPub.getPublic()).toArray('be', 32),
    );
  }

  /**
   * Get the ephemeral id, which is the first 4 bytes of the shared secret generated from the local
   * private key and the ephemeral public key from the device.
   * @internal
   * @returns Buffer
   */
  private _getEphemId () {
    if (this.ephemeralPub === null) return null;
    // EphemId is the first 4 bytes of the hash of the shared secret
    const secret = this._getSharedSecret();
    const hash = Buffer.from(sha256().update(secret).digest('hex'), 'hex');
    return hash.slice(0, 4);
  }

  /**
   * Builds an encrypted request
   * @internal
   */
  private _buildEncRequest (enc_request_code, payload) {
    // Get the ephemeral id - all encrypted requests require there to be an epehemeral public key in
    // order to send
    const ephemId = parseInt(this._getEphemId().toString('hex'), 16);
    // Build the payload and checksum
    const payloadPreCs = Buffer.concat([
      Buffer.from([enc_request_code]),
      payload,
    ]);
    const cs = checksum(payloadPreCs);
    const payloadBuf = Buffer.alloc(payloadPreCs.length + 4);

    // Lattice validates checksums in little endian
    payloadPreCs.copy(payloadBuf, 0);
    payloadBuf.writeUInt32LE(cs, payloadPreCs.length);
    // Encrypt this payload
    const secret = this._getSharedSecret();
    const newEncPayload = aes256_encrypt(payloadBuf, secret);

    // Write to the overall payload. We must use the same length for every encrypted request and
    // must include a 32-bit ephemId along with the encrypted data
    const newPayload = Buffer.alloc(ENC_MSG_LEN + 4);
    // First 4 bytes are the ephemeral id (in little endian)
    newPayload.writeUInt32LE(ephemId, 0);
    // Next N bytes
    newEncPayload.copy(newPayload, 4);
    return this._buildRequest(deviceCodes.ENCRYPTED_REQUEST, newPayload);
  }

  /**
   * Build a request to send to the device.
   * @internal
   * @param request_code {uint8} - 8-bit unsigned integer representing the message request code
   * @param id {buffer} - 4 byte identifier (comes from HSM for subsequent encrypted reqs)
   * @param payload {buffer} - serialized payload
   * @returns {buffer}
   */
  private _buildRequest (request_code, payload) {
    // Length of payload; we add 1 to the payload length to account for the request_code byte
    let L = payload && Buffer.isBuffer(payload) ? payload.length + 1 : 1;
    if (request_code === deviceCodes.ENCRYPTED_REQUEST) {
      L = 1 + payload.length;
    }
    let i = 0;
    const preReq = Buffer.alloc(L + 8);
    // Build the header
    i = preReq.writeUInt8(VERSION_BYTE, i);
    i = preReq.writeUInt8(REQUEST_TYPE_BYTE, i);
    const id = randomBytes(4);
    i = preReq.writeUInt32BE(parseInt(`0x${id.toString('hex')}`), i);
    i = preReq.writeUInt16BE(L, i);
    // Build the payload
    i = preReq.writeUInt8(request_code, i);
    if (L > 1) i = payload.copy(preReq, i);
    // Add the checksum
    const cs = checksum(preReq);
    const req = Buffer.alloc(preReq.length + 4); // 4-byte checksum
    i = preReq.copy(req);
    req.writeUInt32BE(cs, i);
    return req;
  }

  /**
   * Send a request to the device and wait for a response.
   * @internal
   * @returns The response code.
   */
  private _request (payload, encReqCode, cb, retryCount = this.retryCount) {
    if (!this.deviceId) {
      return cb('Device ID is not set. Please set it and try again.');
    } else if (encReqCode && encReqCodes[encReqCode] === undefined) {
      return cb('Unknown encrypted request code.');
    }
    // Encrypt the data if appropriate. Most requests are end-to-end encrypted, but some (e.g.
    // CONNNECT) are not encrypted.
    const data = encReqCode
      ? this._buildEncRequest(encReqCodes[encReqCode], payload)
      : payload;
    const url = `${this.baseUrl}/${this.deviceId}`;
    superagent
      .post(url)
      .timeout(this.timeout)
      .send({ data })
      .then((res) => {
        // Handle formatting or generic HTTP errors
        if (!res || !res.body) {
          return cb(`Invalid response: ${res}`);
        } else if (res.body.status !== 200) {
          return cb(`Error code ${res.body.status}: ${res.body.message}`);
        }
        // Handle retry logic
        const parsed = parseLattice1Response(res.body.message);
        const deviceBusy =
          parsed.responseCode === responseCodes.RESP_ERR_DEV_BUSY ||
          parsed.responseCode === responseCodes.RESP_ERR_GCE_TIMEOUT;
        const wrongWallet =
          parsed.responseCode === responseCodes.RESP_ERR_WRONG_WALLET;
        const invalidEphemId =
          parsed.responseCode === responseCodes.RESP_ERR_INVALID_EPHEM_ID;
        const canRetry = retryCount > 0;
        // Re-connect and/or retry request if needed
        if (canRetry && deviceBusy) {
          // Wait a few seconds and retry
          setTimeout(() => {
            this._request(payload, encReqCode, cb, retryCount - 1);
          }, 3000);
        } else if (canRetry && invalidEphemId) {
          // Encrypted channel got out of sync. Reconnect and retry.
          this.connect(this.deviceId, (err, isPaired) => {
            if (err) {
              // Abort on connection error
              return cb(err);
            } else if (!isPaired) {
              // Abort if we are not paired
              return cb('Not paired to device.');
            }
            this._request(payload, encReqCode, cb, retryCount - 1);
          });
        } else if (canRetry && wrongWallet && !this.skipRetryOnWrongWallet) {
          // Incorrect wallet being requested. Clear wallet state.
          this._resetActiveWallets();
          // Refetch the active wallet.
          this.fetchActiveWallet()
            .then(() => {
              payload = this._replaceWalletUID(encReqCode, payload);
              if (!payload) {
                // Not allowed to retry. Exit here.
                return cb('Wrong wallet. Failed to switch. Please reconnect.');
              }
              this._request(payload, encReqCode, cb, 0);
            })
            .catch((err) => {
              return cb(err);
            });
        } else if (parsed.responseCode || parsed.err) {
          if (parsed.err) {
            return cb(parsed.err);
          }
          cb(responseMsgs[parsed.responseCode] || 'Unknown request failure');
        } else {
          // All good
          cb(null, parsed.data, parsed.responseCode);
        }
      })
      .catch((err) => {
        const isTimeout = err.code === 'ECONNABORTED' && err.errno === 'ETIME';
        if (isTimeout)
          return cb(
            'Timeout waiting for device. Please ensure it is connected to the internet and try again in a minute.',
          );
        else return cb(`Failed to make request to device: ${err.message}`);
      });
  }

  // ----- Device response -----

  /**
   * `_handleConnect` will call `StartPairingMode` on the device, which gives the user 60 seconds to
   * finalize the pairing. This will return an ephemeral public key, which is needed for the next
   * request.
   * - If the device is already paired, this ephemPub is simply used to encrypt the next request.
   * - If the device is not paired, it is needed to pair the device within 60 seconds.
   * @category Device Response
   * @internal
   * @returns true if we are paired to the device already
   */
  private _handleConnect (res) {
    let off = 0;
    const isPaired = res.readUInt8(off) === messageConstants.PAIRED;
    off++;
    // If we are already paired, we get the next ephemeral key
    const pub = res.slice(off, off + 65).toString('hex');
    off += 65;
    // Grab the firmware version (will be 0-length for older fw versions) It is of format
    // |fix|minor|major|reserved|
    this.fwVersion = res.slice(off, off + 4);
    off += 4;
    // Set the public key
    this.ephemeralPub = getP256KeyPairFromPub(pub);
    // If we are already paired, the response will include some encrypted data about the current
    // wallets This data was added in Lattice firmware v0.14.1
    if (isPaired && this._fwVersionGTE(0, 14, 1)) {
      // Later versions of firmware added wallet info
      const encWalletData = res.slice(off, off + 160);
      off += 160;
      const sharedSecret = this._getSharedSecret();
      const decWalletData = aes256_decrypt(encWalletData, sharedSecret);
      // Sanity check to make sure the last part of the decrypted data is empty. The last 2 bytes
      // are AES padding
      if (
        decWalletData[decWalletData.length - 2] !== 0 ||
        decWalletData[decWalletData.length - 1] !== 0
      ) {
        throw new Error('Failed to connect to Lattice.');
      }
      this._parseAndAddWallets(decWalletData);
    }
    // return the state of our pairing
    return isPaired;
  }

  /**
   * All encrypted responses must be decrypted with the previous shared secret. Per specification,
   * decrypted responses will all contain a 65-byte public key as the prefix, which becomes the new
   * `ephemeralPub`.
   * @category Device Response
   * @internal
   */
  private _handleEncResponse (encRes, len) {
    // Decrypt response
    const secret = this._getSharedSecret();
    const encData = encRes.slice(0, ENC_MSG_LEN);
    const res = aes256_decrypt(encData, secret);
    // len does not include a 65-byte pubkey that prefies each encResponse
    len += 65;
    // Validate checksum. It will be the last 4 bytes of the decrypted payload. The length of the
    // decrypted payload will be fixed for each given message type.
    const toCheck = res.slice(0, len);
    const cs = parseInt(`0x${res.slice(len, len + 4).toString('hex')}`);
    const csCheck = checksum(toCheck);
    if (cs !== csCheck)
      return {
        err: `Checksum mismatch in response from Lattice (calculated ${csCheck}, wanted ${cs})`,
      };

    // First 65 bytes is the next ephemeral pubkey
    const pub = res.slice(0, 65).toString('hex');
    try {
      this.ephemeralPub = getP256KeyPairFromPub(pub);
      return { err: null, data: res };
    } catch (e) {
      return {
        err: `Error handling getAddresses response: ${e.toString()}`,
      };
    }
  }

  /**
   * Pair will create a new pairing if the user successfully enters the secret into the device in
   * time. If successful (`status=0`), the device will return a new ephemeral public key, which is
   * used to derive a shared secret for the next request
   * @category Device Response
   * @internal
   * @returns error (or null)
   */
  private _handlePair (encRes) {
    const d = this._handleEncResponse(encRes, decResLengths.empty);
    if (d.err) return d.err;
    this.isPaired = true;
    return null;
  }

  /**
   * @category Device Response
   * @internal
   * @return an array of address strings
   */
  private _handleGetAddresses (encRes, flag) {
    // Handle the encrypted response
    const decrypted = this._handleEncResponse(
      encRes,
      decResLengths.getAddresses,
    );
    if (decrypted.err !== null) return decrypted;

    const addrData = decrypted.data;
    let off = 65; // Skip 65 byte pubkey prefix
    // Look for addresses until we reach the end (a 4 byte checksum)
    const addrs = [];
    // Pubkeys are formatted differently in the response
    const { ED25519_PUB, SECP256K1_PUB } = Constants.GET_ADDR_FLAGS;
    const arePubkeys = flag === ED25519_PUB || flag === SECP256K1_PUB;
    if (arePubkeys) {
      off += 1; // skip uint8 representing pubkey type
    }
    while (off + 4 < decResLengths.getAddresses) {
      if (arePubkeys) {
        // Pubkeys are shorter and are returned as buffers
        const pubBytes = addrData.slice(off, off + 65);
        const isEmpty = pubBytes.every((byte) => byte === 0x00);
        if (!isEmpty && flag === ED25519_PUB) {
          // ED25519 pubkeys are 32 bytes
          addrs.push(pubBytes.slice(0, 32));
        } else if (!isEmpty) {
          // Only other returned pubkeys are ECC, or 65 bytes Note that we return full
          // (uncompressed) ECC pubkeys
          addrs.push(pubBytes);
        }
        off += 65;
      } else {
        // Otherwise we are dealing with address strings
        const addrBytes = addrData.slice(off, off + ADDR_STR_LEN);
        off += ADDR_STR_LEN;
        // Return the UTF-8 representation
        const len = addrBytes.indexOf(0); // First 0 is the null terminator
        if (len > 0) {
          addrs.push(addrBytes.slice(0, len).toString());
        }
      }
    }
    return { data: addrs, err: null };
  }

  /**
   * If there is an active wallet, return null. Otherwise, return an error message.
   * @category Device Response
   * @internal
   * @param encRes - The encrypted response from the device.
   */
  private _handleGetWallets (encRes) {
    const decrypted = this._handleEncResponse(encRes, decResLengths.getWallets);
    if (decrypted.err !== null) {
      return decrypted;
    }
    const res = decrypted.data;
    // Skip 65byte pubkey prefix. WalletDescriptor contains 32byte id + 4byte flag + 35byte name
    this._parseAndAddWallets(res.slice(65));
    if (
      this.activeWallets.internal.uid.equals(EMPTY_WALLET_UID) &&
      this.activeWallets.external.uid.equals(EMPTY_WALLET_UID)
    ) {
      return 'No active wallet.';
    }
    return null;
  }

  // Given a set of wallet data, which contains two wallet descriptors, parse the data and save it
  // to memory
  private _parseAndAddWallets (walletData) {
    // Read the external wallet data first. If it is non-null, the external wallet will be the
    // active wallet of the device and we should save it. If the external wallet is blank, it means
    // there is no card present and we should save and use the interal wallet. If both wallets are
    // empty, it means the device still needs to be set up.
    const walletDescriptorLen = 71;
    // Internal first
    let off = 0;
    this.activeWallets.internal.uid = walletData.slice(off, off + 32);
    this.activeWallets.internal.capabilities = walletData.readUInt32BE(
      off + 32,
    );
    this.activeWallets.internal.name = walletData.slice(
      off + 36,
      off + walletDescriptorLen,
    );
    // Offset the first item
    off += walletDescriptorLen;
    // External
    this.activeWallets.external.uid = walletData.slice(off, off + 32);
    this.activeWallets.external.capabilities = walletData.readUInt32BE(
      off + 32,
    );
    this.activeWallets.external.name = walletData.slice(
      off + 36,
      off + walletDescriptorLen,
    );
  }

  /**
   * `_handleSign` takes the encrypted response from the device and decrypts it. It then parses the
   * decrypted response and returns the data.
   * @category Device Response
   * @internal
   * @param encRes - The encrypted response from the server
   * @param currencyType - The type of currency being signed.
   * @param req - The original request data
   * @returns The transaction data, the transaction hash, and the signature.
   */
  private _handleSign (
    encRes,
    currencyType,
    req = null,
  ): { err: string } | SignData {
    // Handle the encrypted response
    const decrypted = this._handleEncResponse(encRes, decResLengths.sign);
    if (decrypted.err !== null) return { err: decrypted.err };
    const PUBKEY_PREFIX_LEN = 65;
    const PKH_PREFIX_LEN = 20;
    let off = PUBKEY_PREFIX_LEN; // Skip past pubkey prefix
    const res = decrypted.data;
    // Get the change data if we are making a BTC transaction
    let changeRecipient;
    if (currencyType === 'BTC') {
      const changeVersion = bitcoin.getAddressFormat(req.origData.changePath);
      const changePubkeyhash = res.slice(off, off + PKH_PREFIX_LEN);
      off += PKH_PREFIX_LEN;
      changeRecipient = bitcoin.getBitcoinAddress(
        changePubkeyhash,
        changeVersion,
      );
    }
    const DERLength = 74; // max size of a DER signature -- all Lattice sigs are this long
    const SIGS_OFFSET = 10 * DERLength; // 10 signature slots precede 10 pubkey slots
    const PUBKEYS_OFFSET = PUBKEY_PREFIX_LEN + PKH_PREFIX_LEN + SIGS_OFFSET;

    if (currencyType === 'BTC') {
      const compressedPubLength = 33; // Size of compressed public key
      const pubkeys = [];
      const sigs = [];
      let n = 0;
      // Parse the signature for each output -- they are returned in the serialized payload in form
      // [pubkey, sig] There is one signature per output
      while (off < res.length) {
        // Exit out if we have seen all the returned sigs and pubkeys
        if (res[off] !== 0x30) break;
        // Otherwise grab another set Note that all DER sigs returned fill the maximum 74 byte
        // buffer, but also contain a length at off+1, which we use to parse the non-zero data.
        // First get the signature from its slot
        const sigStart = off;
        const sigEnd = off + 2 + res[off + 1];
        sigs.push(res.slice(sigStart, sigEnd));
        // Next, shift by the full set of signatures to hit the respective pubkey NOTE: The data
        // returned is: [<sig0>, <sig1>, ... <sig9>][<pubkey0>, <pubkey1>, ... <pubkey9>]
        const pubStart = n * compressedPubLength + PUBKEYS_OFFSET;
        const pubEnd = (n + 1) * compressedPubLength + PUBKEYS_OFFSET;
        pubkeys.push(res.slice(pubStart, pubEnd));
        // Update offset to hit the next signature slot
        off += DERLength;
        n += 1;
      }
      // Build the transaction data to be serialized
      const preSerializedData = {
        inputs: [],
        outputs: [],
      };

      // First output comes from request dta
      preSerializedData.outputs.push({
        value: req.origData.value,
        recipient: req.origData.recipient,
      });
      if (req.changeData.value > 0) {
        // Second output comes from change data
        preSerializedData.outputs.push({
          value: req.changeData.value,
          recipient: changeRecipient,
        });
      }

      // Add the inputs
      for (let i = 0; i < sigs.length; i++) {
        preSerializedData.inputs.push({
          hash: req.origData.prevOuts[i].txHash,
          index: req.origData.prevOuts[i].index,
          sig: sigs[i],
          pubkey: pubkeys[i],
          signerPath: req.origData.prevOuts[i].signerPath,
        });
      }

      // Finally, serialize the transaction
      const serializedTx = bitcoin.serializeTx(preSerializedData);
      // Generate the transaction hash so the user can look this transaction up later
      const preImageTxHash = serializedTx;
      const txHashPre: Buffer = Buffer.from(
        sha256().update(Buffer.from(preImageTxHash, 'hex')).digest('hex'),
        'hex',
      );
      // Add extra data for debugging/lookup purposes
      return {
        tx: serializedTx,
        txHash: sha256().update(txHashPre).digest('hex'),
        changeRecipient,
        sigs,
      };
    } else if (currencyType === 'ETH') {
      const sig = parseDER(res.slice(off, off + 2 + res[off + 1]));
      off += DERLength;
      const ethAddr = res.slice(off, off + 20);
      // Determine the `v` param and add it to the sig before returning
      const { rawTx, sigWithV } = ethereum.buildEthRawTx(req, sig, ethAddr);
      return {
        tx: `0x${rawTx}`,
        txHash: `0x${ethereum.hashTransaction(rawTx)}`,
        sig: {
          v: sigWithV.v,
          r: sigWithV.r.toString('hex'),
          s: sigWithV.s.toString('hex'),
        },
        signer: ethAddr,
      };
    } else if (currencyType === 'ETH_MSG') {
      const sig = parseDER(res.slice(off, off + 2 + res[off + 1]));
      off += DERLength;
      const signer = res.slice(off, off + 20);
      const validatedSig = ethereum.validateEthereumMsgResponse(
        { signer, sig },
        req,
      );
      return {
        sig: {
          v: validatedSig.v,
          r: validatedSig.r.toString('hex'),
          s: validatedSig.s.toString('hex'),
        },
        signer,
      };
    } else {
      // Generic signing request
      return parseGenericSigningResponse(
        res,
        off,
        req.curveType,
        req.omitPubkey,
      );
    }
  }

  /**
   * Reset the active wallets to empty values.
   * @category Device Response
   * @internal
   */
  private _resetActiveWallets () {
    this.activeWallets.internal.uid = EMPTY_WALLET_UID;
    this.activeWallets.internal.name = null;
    this.activeWallets.internal.capabilities = null;
    this.activeWallets.external.uid = EMPTY_WALLET_UID;
    this.activeWallets.external.name = null;
    this.activeWallets.external.capabilities = null;
    return;
  }

  /**
   * Update the payload with the current wallet UID. Some (not all) requests require the active
   * wallet UID in order for Lattice firmware to accept them. If we get a "wrong wallet" error, the
   * SDK will automatically request the current wallet UID from the device and may retry the
   * request, but the original request payload must be modified.
   */
  private _replaceWalletUID (encReqCode, payload) {
    const wallet = this.getActiveWallet();
    if (!wallet) {
      return null;
    }
    // See if we can modify the payload and retry
    if (encReqCode === 'GET_ADDRESSES') {
      wallet.uid.copy(payload, 0);
      return payload;
    } else if (encReqCode === 'SIGN_TRANSACTION') {
      wallet.uid.copy(payload, 2);
      return payload;
    }
    // Not allowed to retry
    return null;
  }

  /**
   * Return JSON-stringified version of state data. Can be used to rehydrate an SDK session without
   * reconnecting to the target Lattice.
   */
  private _packStateData () {
    try {
      const data = {
        activeWallets: {
          internal: {
            uid: this.activeWallets.internal.uid.toString('hex'),
            name: this.activeWallets.internal.name.toString(),
            capabilities: this.activeWallets.internal.capabilities,
          },
          external: {
            uid: this.activeWallets.external.uid.toString('hex'),
            name: this.activeWallets.external.name.toString(),
            capabilities: this.activeWallets.external.capabilities,
          },
        },
        ephemeralPub: this.ephemeralPub.getPublic().encode('hex'),
        fwVersion: this.fwVersion.toString('hex'),
        deviceId: this.deviceId,
        name: this.name,
        baseUrl: this.baseUrl,
        privKey: this.privKey.toString('hex'),
        retryCount: this.retryCount,
        timeout: this.timeout,
      };
      return JSON.stringify(data);
    } catch (err) {
      console.warn('Could not pack state data.');
      return null;
    }
  }

  /**
   * Unpack a JSON-stringified version of state data and apply it to state. This will allow us to
   * rehydrate an old session.
   */
  private _unpackAndApplyStateData (data) {
    try {
      const unpacked = JSON.parse(data);
      // Attempty to parse the data
      const internalWallet = {
        uid: Buffer.from(unpacked.activeWallets.internal.uid, 'hex'),
        name: Buffer.from(unpacked.activeWallets.internal.name),
        capabilities: unpacked.activeWallets.internal.capabilities,
        external: false,
      };
      const externalWallet = {
        uid: Buffer.from(unpacked.activeWallets.external.uid, 'hex'),
        name: Buffer.from(unpacked.activeWallets.external.name),
        capabilities: unpacked.activeWallets.external.capabilities,
        external: true,
      };
      const ephemeralPubBytes = Buffer.from(unpacked.ephemeralPub, 'hex');
      const fwVersionBytes = Buffer.from(unpacked.fwVersion, 'hex');
      const privKeyBytes = Buffer.from(unpacked.privKey, 'hex');
      // Apply unpacked params
      this.activeWallets.internal = internalWallet;
      this.activeWallets.external = externalWallet;
      this.ephemeralPub = getP256KeyPairFromPub(ephemeralPubBytes);
      this.fwVersion = fwVersionBytes;
      this.deviceId = unpacked.deviceId;
      this.name = unpacked.name;
      this.baseUrl = unpacked.baseUrl;
      this.privKey = privKeyBytes;
      this.key = getP256KeyPair(this.privKey);
      this.retryCount = unpacked.retryCount;
      this.timeout = unpacked.timeout;
    } catch (err) {
      console.warn('Could not apply state data.');
    }
  }

  // Determine if a provided firmware version matches or exceeds the current firmware version
  private _fwVersionGTE(_major: number, _minor: number, _fix: number): boolean {
    const { major, minor, fix } = this.getFwVersion();
    return (
      major > _major ||
      (major >= _major && minor > _minor) ||
      (major >= _major && minor >= _minor && fix >= _fix)
    );
  }

  /**
   * Get the active wallet.
   * @returns The active wallet.
   */
  public getActiveWallet () {
    if (!EMPTY_WALLET_UID.equals(this.activeWallets.external.uid)) {
      return this.activeWallets.external;
    } else if (!EMPTY_WALLET_UID.equals(this.activeWallets.internal.uid)) {
      return this.activeWallets.internal;
    } else {
      return null;
    }
  }

  /**
   * Check if the user has an active wallet"
   * @returns true is user has active wallet
   */
  private hasActiveWallet () {
    return this.getActiveWallet() !== null;
  }

  /**
   * Get 64 bytes representing the public key This is the uncompressed key without the leading 04
   * byte
   * @param LE - Whether to return the public key in little endian format.
   * @returns A Buffer containing the public key.
   */
  private pubKeyBytes (LE = false) {
    const k = this.key.getPublic();
    const p = k.encode('hex');
    const pb = Buffer.from(p, 'hex');
    if (LE === true) {
      // Need to flip X and Y components to little endian
      const x = pb.slice(1, 33).reverse();
      const y = pb.slice(33, 65).reverse();
      // @ts-expect-error - TODO: Find out why Buffer won't accept pb[0]
      return Buffer.concat([pb[0], x, y]);
    } else {
      return pb;
    }
  }
}
