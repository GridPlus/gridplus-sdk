"use strict";(self.webpackChunkgridplus_sdk_docs=self.webpackChunkgridplus_sdk_docs||[]).push([[949],{5624:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var a=n(4848),i=n(8453);const s={},o="\ud83d\udcdc Calldata Decoding",r={id:"tutorials/calldataDecoding",title:"\ud83d\udcdc Calldata Decoding",description:"Calldata decoding is only available with General Signing patterns.",source:"@site/docs/tutorials/calldataDecoding.md",sourceDirName:"tutorials",slug:"/tutorials/calldataDecoding",permalink:"/gridplus-sdk/tutorials/calldataDecoding",draft:!1,unlisted:!1,editUrl:"https://github.com/gridplus/gridplus-sdk/docs/tutorials/calldataDecoding.md",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"\ud83e\uddfe Signing Messages",permalink:"/gridplus-sdk/signing"},next:{title:"\ud83c\udff7\ufe0f Addresses Tags",permalink:"/gridplus-sdk/tutorials/addressTags"}},d={},c=[{value:"EVM Calldata Decoding",id:"evm-calldata-decoding",level:2},{value:"Example",id:"example",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"-calldata-decoding",children:"\ud83d\udcdc Calldata Decoding"}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["Calldata decoding is only available with ",(0,a.jsx)(t.a,{href:"../signing#general-signing",children:"General Signing"})," patterns."]})}),"\n",(0,a.jsxs)(t.p,{children:['Because the Lattice has a large 5" touchscreen display, it is capable of rendering a fair bit of information on any given screen. You can use this screen to display ',(0,a.jsx)(t.strong,{children:"decoded transaction calldata"})," using some common encoding/decoding protocol, such as Ethereum's ",(0,a.jsx)(t.a,{href:"https://docs.soliditylang.org/en/v0.8.17/abi-spec.html",children:"Contract ABI spec"}),". This means that instead of rendering blobs of unreadable hex data, you can instruct the Lattice to render individual parameter values; all you need to do is include ",(0,a.jsx)(t.strong,{children:"decoding data"})," with your transaction request, as will be demonstrated below. Calldata decoding should be integrated with whatever wallet application or service is making transaction requests using this SDK, such as ",(0,a.jsx)(t.a,{href:"https://metamask.io",children:"MetaMask"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"evm-calldata-decoding",children:"EVM Calldata Decoding"}),"\n",(0,a.jsxs)(t.p,{children:["EVM chains (e.g. Ethereum, Polygon, Arbitrum) all use the same ",(0,a.jsx)(t.a,{href:"https://docs.soliditylang.org/en/v0.8.17/abi-spec.html",children:"Contract ABI spec"})," for encoding transaction calldata."]}),"\n",(0,a.jsx)(t.admonition,{type:"note",children:(0,a.jsxs)(t.p,{children:["See ",(0,a.jsx)(t.a,{href:"https://mirror.xyz/alexmiller.eth/kiwpU01XZh-rCgDDRA-jB2-pjosjogGIqCZkxryZ9Oo",children:"this article"})," for more details on the ABI spec and how calldata decoder data is generated under the hood."]})}),"\n",(0,a.jsxs)(t.p,{children:["We first need to look up the ABI definition for the function we are calling. This is done using the util ",(0,a.jsx)(t.a,{href:"../reference/util#fetchcalldatadecoder",children:(0,a.jsx)(t.code,{children:"fetchCalldataDecoder"})}),". Although the logic happens under the hood, it is important to understand that depending on the contract/function being called, the data may be slightly different:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["By default, ",(0,a.jsx)(t.code,{children:"fetchCalldataDecoder"})," will attempt to fetch the full contract ABI from ",(0,a.jsx)(t.a,{href:"https://etherscan.io",children:"Etherscan"})," or one of its sister sites such as ",(0,a.jsx)(t.a,{href:"https://arbiscan.io",children:"Arbiscan"}),". Etherscan et al only return ABI data if the contract ",(0,a.jsx)(t.strong,{children:"source code"})," has been ",(0,a.jsx)(t.strong,{children:"verified"}),' (i.e. the contract is "open source"). If the code has not been verified, we unfortunately cannot use Etherscan to help us decode calldata.']}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["If Etherscan fails to return data, ",(0,a.jsx)(t.code,{children:"fetchCalldataDecoder"})," will look up the ",(0,a.jsx)(t.strong,{children:"canonical ABI definition"})," using ",(0,a.jsx)(t.a,{href:"https://4byte.directory",children:"4byte"}),". As the name implies, this lookup is done using the first four bytes of the transaction calldata. As long as there is a record on 4byte, you should get decoder data back (anyone can add a record to 4byte, so if your function is missing... just add it). This method is worse than Etherscan because the canonical ABI definition does not contain ",(0,a.jsx)(t.strong,{children:"parameter names"}),", so the decoded display will show param names like ",(0,a.jsx)(t.code,{children:"#1"}),", ",(0,a.jsx)(t.code,{children:"#2"}),", etc."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.admonition,{type:"caution",children:[(0,a.jsx)(t.p,{children:"You might be worried about information attacks here. While these are possible, you realistically don't need to worry much. In the case of Etherscan, you can only get decoder data from verified contracts. In the case of 4byte, it is possible to force a collision with a different definition using the same first four bytes, but this is an impractical attack as it would require, at a minimum, changing the function name."}),(0,a.jsx)(t.p,{children:"Furthermore, the Ethereum ABI spec is self-referential; the first 4 bytes of calldata must map to the correct ABI definition and since these 4 bytes are part of the calldata, they are immutable in the context of the transaction. This means it is easy to detect if a given ABI definition is mismatched with the transaction calldata it is supposed to decode. In all such cases, Lattice firmware will fail to decode the calldata and will instead render it as hex, which may tip off the user that something is wrong."}),(0,a.jsx)(t.p,{children:"So in summary, information attacks are limited in scope and their theoretical benefit to an attacker is unclear."})]}),"\n",(0,a.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,a.jsxs)(t.p,{children:["Once you get the decoder data from ",(0,a.jsx)(t.code,{children:"fetchCalldataDecoder"}),", you can include it with your transaction request and... that's it! Here is a code snippet outlining this functionality:"]}),"\n",(0,a.jsxs)(t.admonition,{type:"note",children:[(0,a.jsxs)(t.p,{children:["In the snippet below, we assume ",(0,a.jsx)(t.code,{children:"tx"})," has already been created and is an instance of some ",(0,a.jsx)(t.a,{href:"https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/tx#readme",children:(0,a.jsx)(t.code,{children:"@ethereumjs/tx"})})," transaction type (e.g. ",(0,a.jsx)(t.code,{children:"FeeMarketEIP1559Transaction"}),", ",(0,a.jsx)(t.code,{children:"Transaction"}),", etc)."]}),(0,a.jsxs)(t.p,{children:["The behavior of ",(0,a.jsx)(t.code,{children:"@ethereumjs/tx"})," is outside the scope of this article, but one thing to mention is that different transaction types serialize differently:"]}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"Transaction"}),": ",(0,a.jsx)(t.code,{children:"rlp.encode(tx.getMessageToSign(false))"})]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"FeeMarketEIP1559Transaction"})," and other newer types: ",(0,a.jsx)(t.code,{children:"tx.getMessageToSign(false)"})]}),"\n"]})]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"import { Client, Constants, Utils } from 'gridplus-sdk';\nimport { question } from 'readline-sync';\nconst deviceID = 'XXXXXX';\n\n// Set up your client and connect to the Lattice\nconst client = new Client({ name: 'Calldata Decodooor' });\nconst isPaired = await client.connect(deviceID);\nif (!isPaired) {\n  const secret = await question('Enter pairing secret: ');\n  await client.pair(secret);\n}\n\n// Get the calldata decoder using the `@ethereumjs/tx` `tx` object\nconst { def } = await Utils.fetchCalldataDecoder(\n  tx.input, // Calldata to be decoded\n  tx.to, // Address of the contract we are calling\n  tx.chainId, // Integer containing chain ID, used to determine Etherscan site\n);\n\n// Build the transaction request as you normally would\nconst req = {\n  signerPath,\n  curveType: Constants.SIGNING.CURVES.SECP256K1,\n  hashType: Constants.SIGNING.HASHES.KECCAK256,\n  encodingType: Constants.SIGNING.ENCODINGS.EVM,\n  // As mentioned in the note above, this assumes an `@ethereumjs/tx` object that\n  // is *not* a legacy `Transaction` type, e.g. `FeeMarketEIP1559Transaction`.\n  payload: tx.getMessageToSign(false),\n  // Adding the returned def is all you need to do. If no def was found, this\n  // option will be ignored and the calldata will render as a hex string.\n  decoder: def,\n};\nconst sig = await client.sign(req);\n"})})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var a=n(6540);const i={},s=a.createContext(i);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);