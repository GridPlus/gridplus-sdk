"use strict";(self.webpackChunkgridplus_sdk_docs=self.webpackChunkgridplus_sdk_docs||[]).push([[5047],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),g=d(n),u=i,m=g["".concat(l,".").concat(u)]||g[u]||c[u]||s;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,r=new Array(s);r[0]=g;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var d=2;d<s;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},9437:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return c}});var a=n(7462),i=n(3366),s=(n(7294),n(3905)),r=["components"],o={id:"signing",sidebar_position:3},l="\ud83e\uddfe Signing Transactions and Messages",d={unversionedId:"signing",id:"signing",title:"\ud83e\uddfe Signing Transactions and Messages",description:"The Lattice1 is capable of signing messages on supported curves. For certain message types, it is capable of decoding and displaying the requests in more readable ways.",source:"@site/docs/signing.md",sourceDirName:".",slug:"/signing",permalink:"/gridplus-sdk/signing",draft:!1,editUrl:"https://github.com/gridplus/gridplus-sdk/docs/signing.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"signing",sidebar_position:3},sidebar:"sidebar",previous:{title:"\ud83d\udd11 Addresses and Public Keys",permalink:"/gridplus-sdk/addresses"},next:{title:"\ud83d\udd12 Fetching Encrypted Data",permalink:"/gridplus-sdk/encData"}},p={},c=[{value:"\ud83d\udd8a\ufe0f Requesting Signatures",id:"\ufe0f-requesting-signatures",level:2},{value:"Example: using generic signing",id:"example-using-generic-signing",level:3},{value:"\ud83d\udcc3 Message Decoders",id:"-message-decoders",level:2},{value:"Example: Using the EVM Decoder",id:"example-using-the-evm-decoder",level:3},{value:"Example: Using the Solana Decoder",id:"example-using-the-solana-decoder",level:3},{value:"\ud83d\udcbe Calldata Decoding",id:"-calldata-decoding",level:2},{value:"1\ufe0f\u20e3 EVM Calldata Decoding",id:"1\ufe0f\u20e3-evm-calldata-decoding",level:3},{value:"Example Usage (see <code>test/signing/evm-abi.ts</code> for more examples)",id:"example-usage-see-testsigningevm-abits-for-more-examples",level:4},{value:"\u039e Ethereum (Transaction)",id:"\u03be-ethereum-transaction",level:2},{value:"\u039e Ethereum (Message)",id:"\u03be-ethereum-message",level:2},{value:"<code>personal_sign</code>",id:"personal_sign",level:4},{value:"Example: requesting signature on Ethereum <code>personal_sign</code> message",id:"example-requesting-signature-on-ethereum-personal_sign-message",level:4},{value:"<code>sign_typed_data</code>",id:"sign_typed_data",level:3},{value:"\u20bf Bitcoin",id:"-bitcoin",level:2},{value:"Example: requesting BTC transactions",id:"example-requesting-btc-transactions",level:3}],g={toc:c};function u(e){var t=e.components,n=(0,i.Z)(e,r);return(0,s.kt)("wrapper",(0,a.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"-signing-transactions-and-messages"},"\ud83e\uddfe Signing Transactions and Messages"),(0,s.kt)("p",null,"The Lattice1 is capable of signing messages on supported curves. For certain message types, it is capable of decoding and displaying the requests in more readable ways."),(0,s.kt)("h1",{id:"\ufe0f-general-signing"},"\u270d\ufe0f General Signing"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("em",{parentName:"strong"},"This new signing mode was introduced Lattice firmare ",(0,s.kt)("inlineCode",{parentName:"em"},"v0.14.0"),". GridPlus plans on deprecating the legacy signing mode and replacing it with general signing decoders. This document will be updated as that happens."))),(0,s.kt)("p",null,"You should import ",(0,s.kt)("inlineCode",{parentName:"p"},"Constants")," when using general signing:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { Constants } from `gridplus-sdk`\n")),(0,s.kt)("h2",{id:"\ufe0f-requesting-signatures"},"\ud83d\udd8a\ufe0f Requesting Signatures"),(0,s.kt)("p",null,"General signing allows you to request a signature on any message from a private key derived on any supported curve. Some curves (e.g. ",(0,s.kt)("inlineCode",{parentName:"p"},"secp256k1"),") require a hashing algorithm to be specified in order to hash the message before signing. Other curves (e.g. ",(0,s.kt)("inlineCode",{parentName:"p"},"ed25519"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"bls12_381"),") do not expect hashed messages prior to signing."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"Param"),(0,s.kt)("th",{parentName:"tr",align:"left"},"Location in ",(0,s.kt)("inlineCode",{parentName:"th"},"Constants")),(0,s.kt)("th",{parentName:"tr",align:"left"},"Options"),(0,s.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"Curve"),(0,s.kt)("td",{parentName:"tr",align:"left"},(0,s.kt)("inlineCode",{parentName:"td"},"Constants.SIGNING.CURVES")),(0,s.kt)("td",{parentName:"tr",align:"left"},(0,s.kt)("inlineCode",{parentName:"td"},"SECP256K1"),", ",(0,s.kt)("inlineCode",{parentName:"td"},"ED25519"),", ",(0,s.kt)("inlineCode",{parentName:"td"},"BLS12_381_G2")),(0,s.kt)("td",{parentName:"tr",align:"left"},"Curve on which to derive the signer's private key")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"Hash"),(0,s.kt)("td",{parentName:"tr",align:"left"},(0,s.kt)("inlineCode",{parentName:"td"},"Constants.SIGNING.HASHES")),(0,s.kt)("td",{parentName:"tr",align:"left"},(0,s.kt)("inlineCode",{parentName:"td"},"KECCAK256"),", ",(0,s.kt)("inlineCode",{parentName:"td"},"SHA256"),", ",(0,s.kt)("inlineCode",{parentName:"td"},"NONE")),(0,s.kt)("td",{parentName:"tr",align:"left"},"Hash to use prior to signing. Note that ",(0,s.kt)("inlineCode",{parentName:"td"},"ED25519")," and ",(0,s.kt)("inlineCode",{parentName:"td"},"BLS12_381_G2")," require ",(0,s.kt)("inlineCode",{parentName:"td"},"NONE")," as messages are not prehashed.")))),(0,s.kt)("h3",{id:"example-using-generic-signing"},"Example: using generic signing"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},'const msg = "I am the message to sign"\nconst req = {\n  signerPath: [\n    0x80000000 + 44,\n    0x80000000 + 60,\n    0x80000000,\n  ]\n  curveType: Constants.SIGNING.CURVES.SECP256K1,\n  hashType: Constants.SIGNING.HASHES.KECCAK256,\n  payload: msg\n};\n\nconst sig = await client.sign(req)\n')),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"When using the ",(0,s.kt)("inlineCode",{parentName:"p"},"gridplus-sdk")," in a Node.js application with a version of Node lower than v18, you will need to patch the ",(0,s.kt)("inlineCode",{parentName:"p"},"fetch()")," API in the global scope. One solution is to use the ",(0,s.kt)("inlineCode",{parentName:"p"},"node-fetch")," package. See ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/node-fetch/node-fetch#installation"},"the ",(0,s.kt)("inlineCode",{parentName:"a"},"node-fetch")," README")," for instructions. Other options are available on NPM.")),(0,s.kt)("h2",{id:"-message-decoders"},"\ud83d\udcc3 Message Decoders"),(0,s.kt)("p",null,"By default, the message will be displayed on the Lattice's screen in either ASCII or hex -- if the message contains only ASCII, it will be displayed as such; otherwise it will get printed as a hex string. This means the Lattice can produce a signature for any message you like. However, there are additional decoders that make the request more readable on the Lattice. These decoders can be accessed inside of ",(0,s.kt)("inlineCode",{parentName:"p"},"Constants"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const encodings = Constants.SIGNING.ENCODINGS\n")),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"Encoding"),(0,s.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},(0,s.kt)("inlineCode",{parentName:"td"},"NONE")),(0,s.kt)("td",{parentName:"tr",align:"left"},"Can also use ",(0,s.kt)("inlineCode",{parentName:"td"},"null")," or not specify the ",(0,s.kt)("inlineCode",{parentName:"td"},"encodingType"),". Lattice will display either an ASCII or a hex string depending on the payload.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},(0,s.kt)("inlineCode",{parentName:"td"},"SOLANA")),(0,s.kt)("td",{parentName:"tr",align:"left"},"Used to decode a Solana transaction. Transactions that cannot be decoded will be rejected.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},(0,s.kt)("inlineCode",{parentName:"td"},"EVM")),(0,s.kt)("td",{parentName:"tr",align:"left"},"Used to decode an EVM contract function call. May also be combined with ABI encoding data. To deploy a contract, set ",(0,s.kt)("inlineCode",{parentName:"td"},"to")," as ",(0,s.kt)("inlineCode",{parentName:"td"},"null"),".")))),(0,s.kt)("p",null,"If you do not wish to specify a decoder, you can leave this field empty and the message will display either as ASCII or a hex string on the device."),(0,s.kt)("h3",{id:"example-using-the-evm-decoder"},"Example: Using the EVM Decoder"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const tx = EthTxFactory.fromTxData(txData, { common: req.common });\nconst req = {\n  signerPath: [   // Derivation path of the first requested pubkey\n    0x80000000 + 44,\n    0x80000000 + 60,\n    0x80000000,\n    0,\n    0\n  ]\n  curveType: Constants.SIGNING.CURVES.SECP256K1,\n  hashType: Constants.SIGNING.HASHES.KECCAK256,\n  encodingType: Constants.SIGNING.ENCODINGS.EVM,\n  payload: tx.getMessageToSign(false), // Pass serialized transaction\n};\n\nconst sig = await client.sign(req)\n")),(0,s.kt)("h3",{id:"example-using-the-solana-decoder"},"Example: Using the Solana Decoder"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const msg = solTx.compileMessage().serialize()\nconst req = {\n  signerPath: [   // Derivation path of the first requested pubkey\n    0x80000000 + 44,\n    0x80000000 + 60,\n    0x80000000,\n  ]\n  curveType: Constants.SIGNING.CURVES.ED25519,\n  hashType: Constants.SIGNING.HASHES.NONE,\n  encodingType: Constants.SIGNING.ENCODINGS.SOLANA,\n  payload: msg\n};\n\nconst sig = await client.sign(req)\n")),(0,s.kt)("h2",{id:"-calldata-decoding"},"\ud83d\udcbe Calldata Decoding"),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"All available calldata decoding options will be documented in this section. More may be added as time goes on.")),(0,s.kt)("p",null,'Certain transaction decoder types may support calldata decoding for request data. You can use this feature by including "calldata decoder data" (explained shortly) in a general signing request using the ',(0,s.kt)("inlineCode",{parentName:"p"},"decoder")," request param:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"req.data = {\n  payload: <Raw message to be signed, e.g. serialized transaction>,\n  decoder: <Optional serialized information about decoding the payload>\n}\nawait client.sign(req);\n")),(0,s.kt)("p",null,"If you include a valid calldata decoder, the appearance of the transaction's data on the user's Lattice should transform from a raw hex string to a markdown-style version which displays the function name, parameter names, and values."),(0,s.kt)("h3",{id:"1\ufe0f\u20e3-evm-calldata-decoding"},"1\ufe0f\u20e3 EVM Calldata Decoding"),(0,s.kt)("p",null,"EVM transactions serialize calldata according to the ",(0,s.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/latest/abi-spec.html"},"Ethereum ABI specification"),". The first four bytes of a transaction's ",(0,s.kt)("inlineCode",{parentName:"p"},"data"),' represent the "function selector", which is (sort of) a unique identifier for a given function. '),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"We do not support 100% of all edge cases in the ABI specification, but we do support the vast majority of types.  Please open a pull request or an issue if your request fails to decode on a Lattice.")),(0,s.kt)("p",null,"We expose a method ",(0,s.kt)("inlineCode",{parentName:"p"},"Utils.fetchCalldataDecoder"),", which will attempt to search ",(0,s.kt)("a",{parentName:"p",href:"https://etherscan.io"},"Etherscan")," (or the relevant clone, depending on ",(0,s.kt)("inlineCode",{parentName:"p"},"chainId"),") for the function definition. If none is found it will try ",(0,s.kt)("a",{parentName:"p",href:"https://4byte.directory"},"4byte")," instead. If a function definition is found, ",(0,s.kt)("inlineCode",{parentName:"p"},"fetchCalldataDecoder")," will parse and serialize it for the Lattice. ",(0,s.kt)("inlineCode",{parentName:"p"},"fetchCalldataDecoder")," will return ",(0,s.kt)("inlineCode",{parentName:"p"},"{ abi, def }")," and you will need to pass ",(0,s.kt)("inlineCode",{parentName:"p"},"def")," into the signing request."),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},(0,s.kt)("inlineCode",{parentName:"p"},"fetchCalldataDecoder")," takes in params ",(0,s.kt)("inlineCode",{parentName:"p"},"(tx.input, tx.to, tx.chainId, shouldRecurse)"),". The first 3 come from the transaction object (note that ",(0,s.kt)("inlineCode",{parentName:"p"},"chainId")," must be a regular integer), while ",(0,s.kt)("inlineCode",{parentName:"p"},"shouldRecurse")," is used to flag whether to look up nested definitions, as is typical with contract patterns like ",(0,s.kt)("inlineCode",{parentName:"p"},"multicall"),". You can only use ",(0,s.kt)("inlineCode",{parentName:"p"},"shouldRecurse")," with Lattice firmware v0.16.0 and above.")),(0,s.kt)("h4",{id:"example-usage-see-testsigningevm-abits-for-more-examples"},"Example Usage (see ",(0,s.kt)("inlineCode",{parentName:"h4"},"test/signing/evm-abi.ts")," for more examples)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { Calldata, Utils } from 'gridplus-sdk';\nconst EVMCalldata = Calldata.EVM;\nconst tx = {an @ethereumjs/tx object}\n\n// Get the decoder data. This will attempt to look up an ABI using Etherscan\n// and, if that fails, 4byte.directory.\n// Arguments are: [`data`, `to`, `chainId`, recurse]\n// NOTE: Setting `recurse = true` may result in additional requests. It is \n// used for nested contract patterns such as `multicall`. It is only suppored\n// by Lattice firmware v0.16.0 and up.\nconst { def } = await Utils.fetchCalldataDecoder(tx.input, tx.to, tx.chainId, true);\n// Add the decoder to the request and the transaction should get marked down\nconst req = {\n  signerPath,\n  curveType: Constants.SIGNING.CURVES.SECP256K1,\n  hashType: Constants.SIGNING.HASHES.KECCAK256,\n  encodingType: Constants.SIGNING.ENCODINGS.EVM,\n  payload: tx.getMessageToSign(false), // will serialize the transaction\n  decoder: def\n};\nconst sig = await client.sign(req)\n")),(0,s.kt)("h1",{id:"-legacy-signing"},"\ud83d\udcdc Legacy Signing"),(0,s.kt)("p",null,"Prior to general signing, request data was sent to the Lattice in preformatted ways and was used to build the transaction in firmware. We are phasing out this mechanism, but for now it is how you request Ethereum, Bitcoin, and Ethereum-Message signatures. These signing methods are accessed using the ",(0,s.kt)("inlineCode",{parentName:"p"},"currency")," flag in the request data."),(0,s.kt)("h2",{id:"\u03be-ethereum-transaction"},"\u039e Ethereum (Transaction)"),(0,s.kt)("p",null,"All six Ethereum transactions must be specified in the request data along with a signer path."),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Example: requesting signature on Ethereum transaction")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const txData = {\n  nonce: '0x02',\n  gasPrice: '0x1fe5d61a00',\n  gasLimit: '0x034e97',\n  to: '0x1af768c0a217804cfe1a0fb739230b546a566cd6',\n  value: '0x01cba1761f7ab9870c',\n  data: '0x17e914679b7e160613be4f8c2d3203d236286d74eb9192f6d6f71b9118a42bb033ccd8e8',\n}\n\nconst reqData = {\n  currency: 'ETH',\n  data: {\n    signerPath: [\n      0x80000000 + 44,\n      0x80000000 + 60,\n      0x80000000,\n      0,\n      0,\n    ],\n    ...txData,\n    chain: 5, // Defaults to 1 (i.e. mainnet)\n  }\n}\n\nconst sig = await client.sign(reqData)\n")),(0,s.kt)("h2",{id:"\u03be-ethereum-message"},"\u039e Ethereum (Message)"),(0,s.kt)("p",null,"Two message protocols are supported for Ethereum: ",(0,s.kt)("inlineCode",{parentName:"p"},"personal_sign")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"sign_typed_data"),"."),(0,s.kt)("h4",{id:"personal_sign"},(0,s.kt)("inlineCode",{parentName:"h4"},"personal_sign")),(0,s.kt)("p",null,"This is a protocol to display a simple, human readable message. It includes a prefix to avoid accidentally signing sensitive data. The message included should be a string."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"protocol")," must be specified as ",(0,s.kt)("inlineCode",{parentName:"strong"},'"signPersonal"')),"."),(0,s.kt)("h4",{id:"example-requesting-signature-on-ethereum-personal_sign-message"},"Example: requesting signature on Ethereum ",(0,s.kt)("inlineCode",{parentName:"h4"},"personal_sign")," message"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const reqData = {\n  currency: 'ETH_MSG',\n  data: {\n    signerPath: [\n      0x80000000 + 44,\n      0x80000000 + 60,\n      0x80000000,\n      0,\n      0,\n    ],\n    protocol: 'signPersonal' // You must use this string to specify this protocol\n    payload: 'my message to sign'\n  }\n}\n\nconst sig = await client.sign(reqData)\n")),(0,s.kt)("h3",{id:"sign_typed_data"},(0,s.kt)("inlineCode",{parentName:"h3"},"sign_typed_data")),(0,s.kt)("p",null,"This is used in protocols such as EIP712. It is meant to be an encoding for JSON-like data that can be more human readable."),(0,s.kt)("admonition",{type:"note"},(0,s.kt)("p",{parentName:"admonition"},"Only ",(0,s.kt)("inlineCode",{parentName:"p"},"sign_typed_data")," V3 and V4 are supported.")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},(0,s.kt)("inlineCode",{parentName:"strong"},"protocol")," must be specified as ",(0,s.kt)("inlineCode",{parentName:"strong"},'"eip712"')),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const message = {\n  hello: 'i am a message',\n  goodbye: 1\n}\nconst reqData = {\n  currency: 'ETH_MSG',\n  data: {\n    signerPath: [\n      0x80000000 + 44,\n      0x80000000 + 60,\n      0x80000000,\n      0,\n      0,\n    ],\n    protocol: 'eip712' // You must use this string to specify this protocol\n    payload: message\n  }\n}\n\nconst sig = await client.sign(reqData)\n")),(0,s.kt)("h2",{id:"-bitcoin"},"\u20bf Bitcoin"),(0,s.kt)("p",null,"Bitcoin transactions can be requested by including a set of UTXOs, which include the signer derivation path and spend type. The same ",(0,s.kt)("inlineCode",{parentName:"p"},"purpose")," values are used to determine how UTXOs should be signed:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"If ",(0,s.kt)("inlineCode",{parentName:"li"},"purpose = 44'"),", the input will be signed with p2pkh"),(0,s.kt)("li",{parentName:"ul"},"If ",(0,s.kt)("inlineCode",{parentName:"li"},"purpose = 49'"),", the input will signed with p2sh-p2wpkh"),(0,s.kt)("li",{parentName:"ul"},"If ",(0,s.kt)("inlineCode",{parentName:"li"},"purpose = 84'"),", the input will be signed with p2wpkh")),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"purpose")," of the ",(0,s.kt)("inlineCode",{parentName:"p"},"signerPath")," in the given previous output (a.k.a. UTXO) is used to make the above determination."),(0,s.kt)("h3",{id:"example-requesting-btc-transactions"},"Example: requesting BTC transactions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},'const p2wpkhInputs = [\n  {\n    // Hash of transaction that produced this UTXO\n    txHash: "2aba3db3dc5b1b3ded7231d90fe333e184d24672eb0b6466dbc86228b8996112",\n    // Value of this UTXO in satoshis (1e8 sat = 1 BTC)\n    value: 100000,\n    // Index of this UTXO in the set of outputs in this transaction\n    index: 3,\n    // Owner of this UTXO. Since `purpose` is 84\' this will be spent with p2wpkh,\n    // meaning this is assumed to be a segwit address (starting with bc1)\n    signerPath: [\n      0x80000000 + 84,\n      0x80000000,\n      0x80000000,\n      0,\n      12\n    ]\n  }\n]\n\nconst reqData = {\n  currency: "BTC",\n  data: {\n    prevOuts: p2wpkhInputs,\n    // Recipient can be any legacy, wrapped segwit, or segwit address\n    recipient: "1FKpGnhtR3ZrVcU8hfEdMe8NpweFb2sj5F",\n    // Value (in sats) must be <= (SUM(prevOuts) - fee)\n    value: 50000,\n    // Fee (in sats) goes to the miner\n    fee: 20000,\n    // SUM(prevOuts) - fee goes to the change recipient, which is an\n    // address derived in the same wallet. Again, the `purpose` in this path \n    // determines what address the BTC will be sent to, or more accurately how \n    // the UTXO is locked -- e.g., p2wpkh unlocks differently than p2sh-p2wpkh\n    changePath: [\n      0x80000000 + 84,\n      0x80000000,\n      0x80000000,\n      1, // Typically the change path includes a `1` here\n      0\n    ]\n  }\n}\n\nconst sig = await client.sign(reqData)\n')))}u.isMDXComponent=!0}}]);