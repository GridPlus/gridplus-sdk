"use strict";(self.webpackChunkgridplus_sdk_docs=self.webpackChunkgridplus_sdk_docs||[]).push([[7065],{3905:function(e,t,a){a.d(t,{Zo:function(){return d},kt:function(){return h}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),l=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=l(a),h=r,m=u["".concat(p,".").concat(h)]||u[h]||c[h]||i;return a?n.createElement(m,o(o({ref:t},d),{},{components:a})):n.createElement(m,o({ref:t},d))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=a[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},7722:function(e,t,a){a.r(t),a.d(t,{assets:function(){return d},contentTitle:function(){return p},default:function(){return h},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return c}});var n=a(7462),r=a(3366),i=(a(7294),a(3905)),o=["components"],s={id:"ethDeposits",sidebar_position:5},p="\ud83d\udda5\ufe0f ETH Staking Keys",l={unversionedId:"tutorials/ethDeposits",id:"tutorials/ethDeposits",title:"\ud83d\udda5\ufe0f ETH Staking Keys",description:"ETH staking key management on the Lattice is alpha software and may contain bugs. Please exercise caution when using it.",source:"@site/docs/tutorials/ethDeposits.md",sourceDirName:"tutorials",slug:"/tutorials/ethDeposits",permalink:"/gridplus-sdk/tutorials/ethDeposits",draft:!1,editUrl:"https://github.com/gridplus/gridplus-sdk/docs/tutorials/ethDeposits.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{id:"ethDeposits",sidebar_position:5},sidebar:"sidebar",previous:{title:"\ud83c\udff7\ufe0f Addresses Tags",permalink:"/gridplus-sdk/tutorials/addressTags"},next:{title:"Class: Client",permalink:"/gridplus-sdk/api/classes/client.Client"}},d={},c=[{value:"Generating Keystores",id:"generating-keystores",level:2},{value:"Setting up an Encryption Password",id:"setting-up-an-encryption-password",level:3},{value:"Exporting Encrypted Keystores",id:"exporting-encrypted-keystores",level:3},{value:"Generating Deposit Data",id:"generating-deposit-data",level:2},{value:"BLS vs ETH1 Withdrawals",id:"bls-vs-eth1-withdrawals",level:3},{value:"Example",id:"example",level:2}],u={toc:c};function h(e){var t=e.components,a=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"\ufe0f-eth-staking-keys"},"\ud83d\udda5\ufe0f ETH Staking Keys"),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},"ETH staking key management on the Lattice is alpha software and may contain bugs. Please exercise caution when using it.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Firmware v0.17.0 or above is required for all validator key management functionality.")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Your Lattice ",(0,i.kt)("strong",{parentName:"p"},"cannot")," function as a validator - it can only serve as a ",(0,i.kt)("strong",{parentName:"p"},"key management system"),". In order to participate in the daily activities of Ethereum staking, you must set up a ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.org/en/staking/"},"staking node"),".")),(0,i.kt)("p",null,"If you are interested in staking on Ethereum, you can manage your staking keys using your Lattice as a secure key storage device. There are two components to this:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#generating-keystores"},"Generate Keystores"),": These are your ",(0,i.kt)("strong",{parentName:"p"},"encrypted")," validator private keys, which can be decrypted and used to sign attestations and block proposals using your preferred ",(0,i.kt)("a",{parentName:"p",href:"https://ethereum.org/en/developers/docs/nodes-and-clients/#consensus-clients"},"consensus layer client"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"#generating-deposit-data"},"Generate Geposit Data"),": You must pass a JSON file containing validator(s) information to the ",(0,i.kt)("a",{parentName:"p",href:"https://launchpad.ethereum.org/en/"},"Ethereum Launchpad")," if you wish to create validators using that mechanism, which is the most common and well tested method of starting validators."))),(0,i.kt)("h2",{id:"generating-keystores"},"Generating Keystores"),(0,i.kt)("p",null,"The first step to setting up your validator(s) is to export the private key(s) so that your consensus client software can fulfill your validator duties, such as signing attestations and signing block proposals. Of course, we do not want to export private keys in plain text, as key leakage can result in attacks on your validator. Therefore, we export ",(0,i.kt)("strong",{parentName:"p"},"encrypted")," validator private keys from your Lattice."),(0,i.kt)("h3",{id:"setting-up-an-encryption-password"},"Setting up an Encryption Password"),(0,i.kt)("p",null,"Before you can export keystores, you need to setup an encryption password on your Lattice. You may remove or change this at any time. All exported data will be encrypted using the Lattice's current encryption password, if one exists. If one does not exist, encrypted data export requests will fail and you will be prompted to setup a password."),(0,i.kt)("p",null,"If you would like to manage your device encryption password at any time, go to ",(0,i.kt)("inlineCode",{parentName:"p"},"System Preferences -> Security & Privacy -> Encryption Password")," on your Lattice's screen."),(0,i.kt)("h3",{id:"exporting-encrypted-keystores"},"Exporting Encrypted Keystores"),(0,i.kt)("p",null,"Encrypted keystores are exported using the format defined by ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-2335"},"EIP2335"),". These encrypted files can be loaded directly into any consensus layer client of your choosing. Exporting encrypted keystores is done with ",(0,i.kt)("a",{parentName:"p",href:"../api/classes/client.Client#fetchencrypteddata"},(0,i.kt)("inlineCode",{parentName:"a"},"fetchEncryptedData")),". You may request ",(0,i.kt)("strong",{parentName:"p"},"one")," encrypted private key at a time, corresponding to the specified ",(0,i.kt)("inlineCode",{parentName:"p"},"path"),"."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("ol",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ol"},"Only ",(0,i.kt)("inlineCode",{parentName:"li"},"pbkdf2")," format is supported, meaning ",(0,i.kt)("inlineCode",{parentName:"li"},"scrypt")," is ",(0,i.kt)("strong",{parentName:"li"},"not")," supported. Both formats are valid for staking purposes."),(0,i.kt)("li",{parentName:"ol"},"By default, this will encrypt using ",(0,i.kt)("inlineCode",{parentName:"li"},"262144")," iterations because that was used in the ",(0,i.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-2335"},"canonincal EIP2335 example"),". Note that because Lattice firmware runs on a power-constrained microcontroller, this will take roughly 30 seconds ",(0,i.kt)("em",{parentName:"li"},"per encrypted key exported"),". Setting a smaller value for ",(0,i.kt)("a",{parentName:"li",href:"../api/interfaces/types_fetchEncData.EIP2335KeyExportReq#c"},"optional param ",(0,i.kt)("inlineCode",{parentName:"a"},"c"))," will speed up the encryptions, but will be less secure."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const keystores = [];\nfor (let i = 0; i < numValidators; i++) {\n  // Set the path for this specific validator, where path[2] is the\n  // iterable index, per EIP2334.\n  const path = JSON.parse(JSON.stringify(baseDepositPath));\n  path[2] = i;\n\n  // Export the keystore and save it\n  const exportedKeystore = await client.fetchEncryptedData({\n    schema: Constants.schemas.BLS_KEYSTORE_EIP2335_PBKDF_V4,\n    params: { path, }\n  })\n  keystores.push(exportedKeystore);\n}\n")),(0,i.kt)("h2",{id:"generating-deposit-data"},"Generating Deposit Data"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The following funtionality was developed for the Ethereum network at beacon chain phase 0. Newer network functionality may not be supported.")),(0,i.kt)("p",null,"With our keystores in hand, we need one more piece of data before we can stake: the deposit data. Whereas your keystores are needed by your consensus client, your deposit data is needed by the network to process activation for your validator(s). Deposit data is generated in a JSON format that can be consumed by the popular, official ",(0,i.kt)("a",{parentName:"p",href:"https://launchpad.ethereum.org/en/"},"Ethereum Launchpad"),". This is the same file you would get from the official ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ethereum/staking-deposit-cli"},"Ethereum Staking CLI"),"."),(0,i.kt)("p",null,"As with the encrypted data export, you may only generate data for a single validator at a time, though you can do so in a loop as will be demonstrated. Each deposit data export requires a signature by the corresponding validator. This operation is quite simple and uses the ",(0,i.kt)("a",{parentName:"p",href:"../api/modules/util#getethdepositdata"},(0,i.kt)("inlineCode",{parentName:"a"},"getEthDepositData")," util"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const depositData = [];\nfor (let i = 0; i < numValidators; i++) {\n  // Set the path for this specific validator, where path[2] is the\n  // iterable index, per EIP2334.\n  const path = JSON.parse(JSON.stringify(baseDepositPath));\n  path[2] = i;\n  \n  // Export the deposit data for this path. This involves a signature.\n  const data = await Utils.getEthDepositData(client, path);\n  depositData.push(data.depositData);\n}\n")),(0,i.kt)("h3",{id:"bls-vs-eth1-withdrawals"},"BLS vs ETH1 Withdrawals"),(0,i.kt)("p",null,"When creating deposit data, one must define a key that can ",(0,i.kt)("strong",{parentName:"p"},"withdraw"),' from the validator (a.k.a. deposit key). This is called the "withdrawal key". Currently, there are two options: BLS and ETH1 withdrawal keys.'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"By default, a BLS withdrawal key corresponding to the deposit key will be generated. Per ",(0,i.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-2334"},"EIP2334"),", the generic paths are ",(0,i.kt)("inlineCode",{parentName:"li"},"m/12381/3600/i/0/0")," for deposit keys and ",(0,i.kt)("inlineCode",{parentName:"li"},"m/12381/3600/i/0")," for withdrawal keys. This means that for a given ",(0,i.kt)("inlineCode",{parentName:"li"},"i"),", the withdrawal key is one index up the BIP39 derivation path."),(0,i.kt)("li",{parentName:"ul"},"If you would prefer to give an ETH1 address (i.e. a key derived on the ",(0,i.kt)("inlineCode",{parentName:"li"},"secp256k1")," curve) the power to withdraw for your depositor at ",(0,i.kt)("inlineCode",{parentName:"li"},"m/12381/3600/i/0/0"),", you may pass that address as an optional param, as shown below.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const eth1Addr = '0xf2f5c73fa04406b1995e397b55c24ab1f3ea726c';\n\n// Get deposit data with default BLS withdrawal:\nconst depositDataBLS = await Utils.getEthDepositData(client, path);\n// Get deposit data with ETH1 withdrawal key:\nconst depositDataETH1 = await Utils.getEthDepositData(client, path, { withdrawalKey: eth1Addr });\n")),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("p",null,"With your keystores and deposit data in hand, we are ready to start validating! Let's just export the data into JSON files. Here is the full script with a few modifications, including JSON file export:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Client, Constants, Utils } from 'gridplus-sdk';\nimport { question } from 'readline-sync';\nimport { writeFileSync } from 'fs';\nconst deviceID = 'XXXXXX';\nconst numValidators = 5;\nconst baseDepositPath = [ 12381, 3600, 0, 0, 0 ];\n\n// Connect to your Lattice\nconst client = new Client({ name: 'ETH Depositooor' });\nconst isPaired = await client.connect(deviceID);\nif (!isPaired) {\n  const secret = await question('Enter pairing secret: ');\n  await client.pair(secret);\n}\n\n// Get the validator data\nconst depositData = [];\nconst keystores = [];\nfor (let i = 0; i < numValidators; i++) {\n  // Set the path for this specific validator, where path[2] is the\n  // iterable index, per EIP2334.\n  const path = JSON.parse(JSON.stringify(baseDepositPath));\n  path[2] = i;\n\n  // Export the keystore and save it\n  const exportedKeystore = await client.fetchEncryptedData({\n    schema: Constants.schemas.BLS_KEYSTORE_EIP2335_PBKDF_V4,\n    params: { path, }\n  })\n  writeFileSync(`validator_keystore_${i}.json`, exportedKeystore);\n\n  // Export the deposit data for this path. This involves a signature.\n  const data = await Utils.getEthDepositData(client, path);\n  depositData.push(data.depositData);\n}\n\n// Save the depositData\nwriteFileSync(`deposit_data.json`, JSON.stringify(depositData));\n")))}h.isMDXComponent=!0}}]);