"use strict";(self.webpackChunkgridplus_sdk_docs=self.webpackChunkgridplus_sdk_docs||[]).push([[6840],{3905:function(t,e,n){n.d(e,{Zo:function(){return c},kt:function(){return g}});var a=n(7294);function i(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){i(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,i=function(t,e){if(null==t)return{};var n,a,i={},r=Object.keys(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}var s=a.createContext({}),d=function(t){var e=a.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},c=function(t){var e=d(t.components);return a.createElement(s.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,i=t.mdxType,r=t.originalType,s=t.parentName,c=o(t,["components","mdxType","originalType","parentName"]),u=d(n),g=i,m=u["".concat(s,".").concat(g)]||u[g]||p[g]||r;return n?a.createElement(m,l(l({ref:e},c),{},{components:n})):a.createElement(m,l({ref:e},c))}));function g(t,e){var n=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var r=n.length,l=new Array(r);l[0]=u;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=t,o.mdxType="string"==typeof t?t:i,l[1]=o;for(var d=2;d<r;d++)l[d]=n[d];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4925:function(t,e,n){n.r(e),n.d(e,{assets:function(){return c},contentTitle:function(){return s},default:function(){return g},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return p}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],o={id:"getting-started",sidebar_position:1},s="\ud83c\udfac Getting Started",d={unversionedId:"getting-started",id:"getting-started",title:"\ud83c\udfac Getting Started",description:"First install this SDK with:",source:"@site/docs/gettingStarted.md",sourceDirName:".",slug:"/getting-started",permalink:"/gridplus-sdk/getting-started",draft:!1,editUrl:"https://github.com/gridplus/gridplus-sdk/docs/gettingStarted.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"getting-started",sidebar_position:1},sidebar:"sidebar",previous:{title:"Introduction",permalink:"/gridplus-sdk/"},next:{title:"\ud83d\udd11 Addresses and Public Keys",permalink:"/gridplus-sdk/addresses"}},c={},p=[{value:"\ud83d\udd17 Connecting to a Lattice",id:"-connecting-to-a-lattice",level:2},{value:"1\ufe0f\u20e3 Pairing with a new Lattice",id:"1\ufe0f\u20e3-pairing-with-a-new-lattice",level:3},{value:"Example: pairing with a Lattice",id:"example-pairing-with-a-lattice",level:4},{value:"2\ufe0f\u20e3 Connecting to a known Lattice",id:"2\ufe0f\u20e3-connecting-to-a-known-lattice",level:3},{value:"Example: connecting to a known Lattice",id:"example-connecting-to-a-known-lattice",level:4},{value:"3\ufe0f\u20e3 Rehydrating an SDK session",id:"3\ufe0f\u20e3-rehydrating-an-sdk-session",level:3},{value:"Example: drying and rehydrating a client session",id:"example-drying-and-rehydrating-a-client-session",level:4}],u={toc:p};function g(t){var e=t.components,n=(0,i.Z)(t,l);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"-getting-started"},"\ud83c\udfac Getting Started"),(0,r.kt)("p",null,"First install this SDK with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save gridplus-sdk\n")),(0,r.kt)("p",null,"To connect to a Lattice, you need to create an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"Client"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Client } from 'gridplus-sdk'\n")),(0,r.kt)("p",null,"You can use the following options:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Param"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Required"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"name")),(0,r.kt)("td",{parentName:"tr",align:"left"},"string"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Y"),(0,r.kt)("td",{parentName:"tr",align:"left"},"A human readable name for your app. This will be displayed with your app's pairing on the user's Lattice.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"privKey")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"Buffer")),(0,r.kt)("td",{parentName:"tr",align:"left"},"N"),(0,r.kt)("td",{parentName:"tr",align:"left"},"32-byte buffer, not required but highly recommended. If none is specified, a random one will be created at initialization. This is used to build the encrypted channel. If you want to manually restart a connection with a new ",(0,r.kt)("inlineCode",{parentName:"td"},"Client")," instance, you will need to use the same ",(0,r.kt)("inlineCode",{parentName:"td"},"privKey")," in the constructor.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"retryCount")),(0,r.kt)("td",{parentName:"tr",align:"left"},"number"),(0,r.kt)("td",{parentName:"tr",align:"left"},"N"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Default is 3. Number of automatic retries allowed per request. Covers timeouts and certain device errors.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"timeout")),(0,r.kt)("td",{parentName:"tr",align:"left"},"number"),(0,r.kt)("td",{parentName:"tr",align:"left"},"N"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Milliseconds to timeout HTTP request. Defaults to 60s.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"stateData")),(0,r.kt)("td",{parentName:"tr",align:"left"},"string"),(0,r.kt)("td",{parentName:"tr",align:"left"},"N"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Used to rehydrate a session without other params. Result of call to ",(0,r.kt)("inlineCode",{parentName:"td"},"getStateData()"),".")))),(0,r.kt)("h2",{id:"-connecting-to-a-lattice"},"\ud83d\udd17 Connecting to a Lattice"),(0,r.kt)("p",null,"Once ",(0,r.kt)("inlineCode",{parentName:"p"},"Client")," is initialized, you need to connect to the target Lattice. This can happen one of three ways:"),(0,r.kt)("h3",{id:"1\ufe0f\u20e3-pairing-with-a-new-lattice"},"1\ufe0f\u20e3 Pairing with a new Lattice"),(0,r.kt)("p",null,"If you have not setup a pairing with the Lattice in question, you will need to do that first."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Call ",(0,r.kt)("inlineCode",{parentName:"li"},"connect")," with the ",(0,r.kt)("inlineCode",{parentName:"li"},"deviceId")," of the target Lattice"),(0,r.kt)("li",{parentName:"ol"},"The Lattice should generate and display a pairing code, valid for 60 seconds. Call ",(0,r.kt)("inlineCode",{parentName:"li"},"pair")," with this code."),(0,r.kt)("li",{parentName:"ol"},"If successful, you should now have a pairing between the SDK and the Lattice. This pairing maintains an encrypted channel. If that ever gets out of sync, it should repair automatically with a retry.")),(0,r.kt)("h4",{id:"example-pairing-with-a-lattice"},"Example: pairing with a Lattice"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const isPaired = await client.connect(deviceID)\nif (!isPaired) {\n  // Wait for the user to enter the pairing secret displayed on the device  \n  const secret = await question('Enter pairing secret: ')\n  await client.pair(secret)\n}\n")),(0,r.kt)("h3",{id:"2\ufe0f\u20e3-connecting-to-a-known-lattice"},"2\ufe0f\u20e3 Connecting to a known Lattice"),(0,r.kt)("p",null,"If the Lattice in question already has a pairing with your app (and therefore a recoverable encrypted channel), the connection process is easy."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Call ",(0,r.kt)("inlineCode",{parentName:"li"},"connect")," with the ",(0,r.kt)("inlineCode",{parentName:"li"},"deviceId")," of the target Lattice")),(0,r.kt)("h4",{id:"example-connecting-to-a-known-lattice"},"Example: connecting to a known Lattice"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const isPaired = await client.connect(deviceID)\n\nexpect(isPaired).to.equal(true)\n")),(0,r.kt)("h3",{id:"3\ufe0f\u20e3-rehydrating-an-sdk-session"},"3\ufe0f\u20e3 Rehydrating an SDK session"),(0,r.kt)("p",null,"You can always start a new SDK session with the same ",(0,r.kt)("inlineCode",{parentName:"p"},"privKey")," in the constructor, which will always build an encrypted channel when you call ",(0,r.kt)("inlineCode",{parentName:"p"},"connect")," on a paired Lattice. However, you can skip this step by exporting state data and then using that in the constructor. First you need to get the state data before you stop using the connection."),(0,r.kt)("h4",{id:"example-drying-and-rehydrating-a-client-session"},"Example: drying and rehydrating a client session"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// Fetch some addresses from existing client\nconst addrs1 = await client.getAddresses(addrReqData)\n\n// Capture the state data from that client\nconst stateData = client.getStateData()\n\n// Create a new client with the state data\nconst clientDos = new Client({ stateData })\n\n// You can now call this without connecting\nconst addrs2 = await clientDos.getAddresses(addrReqData)\n\n// The addresses should match and there should be no errors\nexpect(addrs1).to.equal(addrs2)\n")))}g.isMDXComponent=!0}}]);